From f6c165561ae16ba5862cca0aacfbea275f17c1ce Mon Sep 17 00:00:00 2001
From: Robert Nelson <robertcnelson@gmail.com>
Date: Mon, 23 Sep 2019 09:58:00 -0500
Subject: [PATCH] backports: exfat: from: linux.git

Signed-off-by: Robert Nelson <robertcnelson@gmail.com>
---
 drivers/staging/exfat/Kconfig       |  10 +
 drivers/staging/exfat/exfat.h       |  12 +-
 drivers/staging/exfat/exfat_cache.c |   2 +
 drivers/staging/exfat/exfat_core.c  | 305 ++++++++++----------
 drivers/staging/exfat/exfat_nls.c   |   2 +-
 drivers/staging/exfat/exfat_super.c | 420 +++++++++++-----------------
 6 files changed, 335 insertions(+), 416 deletions(-)

diff --git a/drivers/staging/exfat/Kconfig b/drivers/staging/exfat/Kconfig
index 78b32aa2ca19..290dbfc7ace1 100644
--- a/drivers/staging/exfat/Kconfig
+++ b/drivers/staging/exfat/Kconfig
@@ -1,9 +1,19 @@
 config EXFAT_FS
 	tristate "exFAT fs support"
+	depends on BLOCK
 	select NLS
 	help
 	  This adds support for the exFAT file system.
 
+config EXFAT_DONT_MOUNT_VFAT
+	bool "Prohibit mounting of fat/vfat filesysems by exFAT"
+	depends on EXFAT_FS
+	default y
+	help
+	  By default, the exFAT driver will only mount exFAT filesystems, and refuse
+	  to mount fat/vfat filesystems.  Set this to 'n' to allow the exFAT driver
+	  to mount these filesystems.
+
 config EXFAT_DISCARD
 	bool "enable discard support"
 	depends on EXFAT_FS
diff --git a/drivers/staging/exfat/exfat.h b/drivers/staging/exfat/exfat.h
index bae180e10609..6c12f2d79f4d 100644
--- a/drivers/staging/exfat/exfat.h
+++ b/drivers/staging/exfat/exfat.h
@@ -86,9 +86,6 @@
 #define CLUSTER_16(x)		((u16)(x))
 #define CLUSTER_32(x)		((u32)(x))
 
-#define FALSE			0
-#define TRUE			1
-
 #define START_SECTOR(x)							\
 	((((sector_t)((x) - 2)) << p_fs->sectors_per_clu_bits) +	\
 	 p_fs->data_start_sector)
@@ -162,14 +159,15 @@
 /* Upcase table macro */
 #define HIGH_INDEX_BIT	(8)
 #define HIGH_INDEX_MASK	(0xFF00)
-#define LOW_INDEX_BIT	(16-HIGH_INDEX_BIT)
-#define UTBL_ROW_COUNT	(1<<LOW_INDEX_BIT)
-#define UTBL_COL_COUNT	(1<<HIGH_INDEX_BIT)
+#define LOW_INDEX_BIT	(16 - HIGH_INDEX_BIT)
+#define UTBL_ROW_COUNT	BIT(LOW_INDEX_BIT)
+#define UTBL_COL_COUNT	BIT(HIGH_INDEX_BIT)
 
 static inline u16 get_col_index(u16 i)
 {
 	return i >> LOW_INDEX_BIT;
 }
+
 static inline u16 get_row_index(u16 i)
 {
 	return i & ~HIGH_INDEX_MASK;
@@ -690,7 +688,7 @@ struct exfat_mount_options {
 };
 
 #define EXFAT_HASH_BITS		8
-#define EXFAT_HASH_SIZE		(1UL << EXFAT_HASH_BITS)
+#define EXFAT_HASH_SIZE		BIT(EXFAT_HASH_BITS)
 
 /*
  * EXFAT file system in-core superblock data
diff --git a/drivers/staging/exfat/exfat_cache.c b/drivers/staging/exfat/exfat_cache.c
index f05d692c2b1e..1565ce65d39f 100644
--- a/drivers/staging/exfat/exfat_cache.c
+++ b/drivers/staging/exfat/exfat_cache.c
@@ -369,6 +369,8 @@ static s32 __FAT_write(struct super_block *sb, u32 loc, u32 content)
 				FAT_modify(sb, sec);
 
 				fat_sector = FAT_getblk(sb, ++sec);
+				if (!fat_sector)
+					return -1;
 				fat_sector[0] = (u8)((fat_sector[0] & 0xF0) |
 						     (content >> 8));
 			} else {
diff --git a/drivers/staging/exfat/exfat_core.c b/drivers/staging/exfat/exfat_core.c
index 9f76ca175c80..b3e9cf725cf5 100644
--- a/drivers/staging/exfat/exfat_core.c
+++ b/drivers/staging/exfat/exfat_core.c
@@ -11,7 +11,6 @@
 #include <linux/slab.h>
 #include "exfat.h"
 
-
 static void __set_sb_dirty(struct super_block *sb)
 {
 	struct exfat_sb_info *sbi = EXFAT_SB(sb);
@@ -101,7 +100,7 @@ void fs_set_vol_flags(struct super_block *sb, u32 new_flag)
 	p_fs->vol_flag = new_flag;
 
 	if (p_fs->vol_type == EXFAT) {
-		if (p_fs->pbr_bh == NULL) {
+		if (!p_fs->pbr_bh) {
 			if (sector_read(sb, p_fs->PBR_sector,
 					&p_fs->pbr_bh, 1) != FFS_SUCCESS)
 				return;
@@ -205,7 +204,7 @@ s32 fat_alloc_cluster(struct super_block *sb, s32 num_alloc,
 
 			if ((--num_alloc) == 0) {
 				p_fs->clu_srch_ptr = new_clu;
-				if (p_fs->used_clusters != (u32) ~0)
+				if (p_fs->used_clusters != UINT_MAX)
 					p_fs->used_clusters += num_clusters;
 
 				return num_clusters;
@@ -216,7 +215,7 @@ s32 fat_alloc_cluster(struct super_block *sb, s32 num_alloc,
 	}
 
 	p_fs->clu_srch_ptr = new_clu;
-	if (p_fs->used_clusters != (u32) ~0)
+	if (p_fs->used_clusters != UINT_MAX)
 		p_fs->used_clusters += num_clusters;
 
 	return num_clusters;
@@ -231,7 +230,7 @@ s32 exfat_alloc_cluster(struct super_block *sb, s32 num_alloc,
 
 	hint_clu = p_chain->dir;
 	if (hint_clu == CLUSTER_32(~0)) {
-		hint_clu = test_alloc_bitmap(sb, p_fs->clu_srch_ptr-2);
+		hint_clu = test_alloc_bitmap(sb, p_fs->clu_srch_ptr - 2);
 		if (hint_clu == CLUSTER_32(~0))
 			return 0;
 	} else if (hint_clu >= p_fs->num_clusters) {
@@ -243,7 +242,7 @@ s32 exfat_alloc_cluster(struct super_block *sb, s32 num_alloc,
 
 	p_chain->dir = CLUSTER_32(~0);
 
-	while ((new_clu = test_alloc_bitmap(sb, hint_clu-2)) != CLUSTER_32(~0)) {
+	while ((new_clu = test_alloc_bitmap(sb, hint_clu - 2)) != CLUSTER_32(~0)) {
 		if (new_clu != hint_clu) {
 			if (p_chain->flags == 0x03) {
 				exfat_chain_cont_cluster(sb, p_chain->dir,
@@ -252,7 +251,7 @@ s32 exfat_alloc_cluster(struct super_block *sb, s32 num_alloc,
 			}
 		}
 
-		if (set_alloc_bitmap(sb, new_clu-2) != FFS_SUCCESS)
+		if (set_alloc_bitmap(sb, new_clu - 2) != FFS_SUCCESS)
 			return -1;
 
 		num_clusters++;
@@ -274,7 +273,7 @@ s32 exfat_alloc_cluster(struct super_block *sb, s32 num_alloc,
 
 		if ((--num_alloc) == 0) {
 			p_fs->clu_srch_ptr = hint_clu;
-			if (p_fs->used_clusters != (u32) ~0)
+			if (p_fs->used_clusters != UINT_MAX)
 				p_fs->used_clusters += num_clusters;
 
 			p_chain->size += num_clusters;
@@ -294,7 +293,7 @@ s32 exfat_alloc_cluster(struct super_block *sb, s32 num_alloc,
 	}
 
 	p_fs->clu_srch_ptr = hint_clu;
-	if (p_fs->used_clusters != (u32) ~0)
+	if (p_fs->used_clusters != UINT_MAX)
 		p_fs->used_clusters += num_clusters;
 
 	p_chain->size += num_clusters;
@@ -325,7 +324,7 @@ void fat_free_cluster(struct super_block *sb, struct chain_t *p_chain,
 		if (do_relse) {
 			sector = START_SECTOR(clu);
 			for (i = 0; i < p_fs->sectors_per_clu; i++)
-				buf_release(sb, sector+i);
+				buf_release(sb, sector + i);
 		}
 
 		prev = clu;
@@ -338,7 +337,7 @@ void fat_free_cluster(struct super_block *sb, struct chain_t *p_chain,
 
 	} while (clu != CLUSTER_32(~0));
 
-	if (p_fs->used_clusters != (u32) ~0)
+	if (p_fs->used_clusters != UINT_MAX)
 		p_fs->used_clusters -= num_clusters;
 }
 
@@ -368,10 +367,10 @@ void exfat_free_cluster(struct super_block *sb, struct chain_t *p_chain,
 			if (do_relse) {
 				sector = START_SECTOR(clu);
 				for (i = 0; i < p_fs->sectors_per_clu; i++)
-					buf_release(sb, sector+i);
+					buf_release(sb, sector + i);
 			}
 
-			if (clr_alloc_bitmap(sb, clu-2) != FFS_SUCCESS)
+			if (clr_alloc_bitmap(sb, clu - 2) != FFS_SUCCESS)
 				break;
 			clu++;
 
@@ -385,10 +384,10 @@ void exfat_free_cluster(struct super_block *sb, struct chain_t *p_chain,
 			if (do_relse) {
 				sector = START_SECTOR(clu);
 				for (i = 0; i < p_fs->sectors_per_clu; i++)
-					buf_release(sb, sector+i);
+					buf_release(sb, sector + i);
 			}
 
-			if (clr_alloc_bitmap(sb, clu-2) != FFS_SUCCESS)
+			if (clr_alloc_bitmap(sb, clu - 2) != FFS_SUCCESS)
 				break;
 
 			if (FAT_read(sb, clu, &clu) == -1)
@@ -397,7 +396,7 @@ void exfat_free_cluster(struct super_block *sb, struct chain_t *p_chain,
 		} while ((clu != CLUSTER_32(0)) && (clu != CLUSTER_32(~0)));
 	}
 
-	if (p_fs->used_clusters != (u32) ~0)
+	if (p_fs->used_clusters != UINT_MAX)
 		p_fs->used_clusters -= num_clusters;
 }
 
@@ -474,7 +473,7 @@ s32 exfat_count_used_clusters(struct super_block *sb)
 	map_i = map_b = 0;
 
 	for (i = 2; i < p_fs->num_clusters; i += 8) {
-		k = *(((u8 *) p_fs->vol_amap[map_i]->b_data) + map_b);
+		k = *(((u8 *)p_fs->vol_amap[map_i]->b_data) + map_b);
 		count += used_bit[k];
 
 		if ((++map_b) >= p_bd->sector_size) {
@@ -492,7 +491,7 @@ void exfat_chain_cont_cluster(struct super_block *sb, u32 chain, s32 len)
 		return;
 
 	while (len > 1) {
-		if (FAT_write(sb, chain, chain+1) < 0)
+		if (FAT_write(sb, chain, chain + 1) < 0)
 			break;
 		chain++;
 		len--;
@@ -537,21 +536,21 @@ s32 load_alloc_bitmap(struct super_block *sb)
 
 			if (ep->flags == 0x0) {
 				p_fs->map_clu  = GET32_A(ep->start_clu);
-				map_size = (u32) GET64_A(ep->size);
+				map_size = (u32)GET64_A(ep->size);
 
-				p_fs->map_sectors = ((map_size-1) >> p_bd->sector_size_bits) + 1;
+				p_fs->map_sectors = ((map_size - 1) >> p_bd->sector_size_bits) + 1;
 
 				p_fs->vol_amap = kmalloc_array(p_fs->map_sectors,
 							       sizeof(struct buffer_head *),
 							       GFP_KERNEL);
-				if (p_fs->vol_amap == NULL)
+				if (!p_fs->vol_amap)
 					return FFS_MEMORYERR;
 
 				sector = START_SECTOR(p_fs->map_clu);
 
 				for (j = 0; j < p_fs->map_sectors; j++) {
 					p_fs->vol_amap[j] = NULL;
-					ret = sector_read(sb, sector+j, &(p_fs->vol_amap[j]), 1);
+					ret = sector_read(sb, sector + j, &(p_fs->vol_amap[j]), 1);
 					if (ret != FFS_SUCCESS) {
 						/*  release all buffers and free vol_amap */
 						i = 0;
@@ -602,7 +601,7 @@ s32 set_alloc_bitmap(struct super_block *sb, u32 clu)
 
 	sector = START_SECTOR(p_fs->map_clu) + i;
 
-	exfat_bitmap_set((u8 *) p_fs->vol_amap[i]->b_data, b);
+	exfat_bitmap_set((u8 *)p_fs->vol_amap[i]->b_data, b);
 
 	return sector_write(sb, sector, p_fs->vol_amap[i], 0);
 }
@@ -624,7 +623,7 @@ s32 clr_alloc_bitmap(struct super_block *sb, u32 clu)
 
 	sector = START_SECTOR(p_fs->map_clu) + i;
 
-	exfat_bitmap_clear((u8 *) p_fs->vol_amap[i]->b_data, b);
+	exfat_bitmap_clear((u8 *)p_fs->vol_amap[i]->b_data, b);
 
 	return sector_write(sb, sector, p_fs->vol_amap[i], 0);
 
@@ -656,7 +655,7 @@ u32 test_alloc_bitmap(struct super_block *sb, u32 clu)
 	map_b = (clu >> 3) & p_bd->sector_size_mask;
 
 	for (i = 2; i < p_fs->num_clusters; i += 8) {
-		k = *(((u8 *) p_fs->vol_amap[map_i]->b_data) + map_b);
+		k = *(((u8 *)p_fs->vol_amap[map_i]->b_data) + map_b);
 		if (clu_mask > 0) {
 			k |= clu_mask;
 			clu_mask = 0;
@@ -686,7 +685,7 @@ void sync_alloc_bitmap(struct super_block *sb)
 	int i;
 	struct fs_info_t *p_fs = &(EXFAT_SB(sb)->fs_info);
 
-	if (p_fs->vol_amap == NULL)
+	if (!p_fs->vol_amap)
 		return;
 
 	for (i = 0; i < p_fs->map_sectors; i++)
@@ -706,7 +705,7 @@ static s32 __load_upcase_table(struct super_block *sb, sector_t sector,
 	struct buffer_head *tmp_bh = NULL;
 	sector_t end_sector = num_sectors + sector;
 
-	u8	skip = FALSE;
+	bool	skip = false;
 	u32	index = 0;
 	u16	uni = 0;
 	u16 **upcase_table;
@@ -715,7 +714,7 @@ static s32 __load_upcase_table(struct super_block *sb, sector_t sector,
 
 	upcase_table = p_fs->vol_utbl = kmalloc(UTBL_COL_COUNT * sizeof(u16 *),
 						GFP_KERNEL);
-	if (upcase_table == NULL)
+	if (!upcase_table)
 		return FFS_MEMORYERR;
 	memset(upcase_table, 0, UTBL_COL_COUNT * sizeof(u16 *));
 
@@ -729,7 +728,7 @@ static s32 __load_upcase_table(struct super_block *sb, sector_t sector,
 		sector++;
 
 		for (i = 0; i < p_bd->sector_size && index <= 0xFFFF; i += 2) {
-			uni = GET16(((u8 *) tmp_bh->b_data)+i);
+			uni = GET16(((u8 *)tmp_bh->b_data) + i);
 
 			checksum = ((checksum & 1) ? 0x80000000 : 0) +
 				   (checksum >> 1) + *(((u8 *)tmp_bh->b_data) +
@@ -743,19 +742,19 @@ static s32 __load_upcase_table(struct super_block *sb, sector_t sector,
 				index += uni;
 				pr_debug("to 0x%X (amount of 0x%X)\n",
 					 index, uni);
-				skip = FALSE;
-			} else if (uni == index)
+				skip = false;
+			} else if (uni == index) {
 				index++;
-			else if (uni == 0xFFFF)
-				skip = TRUE;
-			else { /* uni != index , uni != 0xFFFF */
+			} else if (uni == 0xFFFF) {
+				skip = true;
+			} else { /* uni != index , uni != 0xFFFF */
 				u16 col_index = get_col_index(index);
 
-				if (upcase_table[col_index] == NULL) {
+				if (!upcase_table[col_index]) {
 					pr_debug("alloc = 0x%X\n", col_index);
 					upcase_table[col_index] = kmalloc_array(UTBL_ROW_COUNT,
 						sizeof(u16), GFP_KERNEL);
-					if (upcase_table[col_index] == NULL) {
+					if (!upcase_table[col_index]) {
 						ret = FFS_MEMORYERR;
 						goto error;
 					}
@@ -788,37 +787,37 @@ static s32 __load_default_upcase_table(struct super_block *sb)
 	u32 j;
 	struct fs_info_t *p_fs = &(EXFAT_SB(sb)->fs_info);
 
-	u8	skip = FALSE;
+	bool	skip = false;
 	u32	index = 0;
 	u16	uni = 0;
 	u16 **upcase_table;
 
 	upcase_table = p_fs->vol_utbl = kmalloc(UTBL_COL_COUNT * sizeof(u16 *),
 						GFP_KERNEL);
-	if (upcase_table == NULL)
+	if (!upcase_table)
 		return FFS_MEMORYERR;
 	memset(upcase_table, 0, UTBL_COL_COUNT * sizeof(u16 *));
 
-	for (i = 0; index <= 0xFFFF && i < NUM_UPCASE*2; i += 2) {
+	for (i = 0; index <= 0xFFFF && i < NUM_UPCASE * 2; i += 2) {
 		uni = GET16(uni_upcase + i);
 		if (skip) {
 			pr_debug("skip from 0x%X ", index);
 			index += uni;
 			pr_debug("to 0x%X (amount of 0x%X)\n", index, uni);
-			skip = FALSE;
-		} else if (uni == index)
+			skip = false;
+		} else if (uni == index) {
 			index++;
-		else if (uni == 0xFFFF)
-			skip = TRUE;
-		else { /* uni != index , uni != 0xFFFF */
+		} else if (uni == 0xFFFF) {
+			skip = true;
+		} else { /* uni != index , uni != 0xFFFF */
 			u16 col_index = get_col_index(index);
 
-			if (upcase_table[col_index] == NULL) {
+			if (!upcase_table[col_index]) {
 				pr_debug("alloc = 0x%X\n", col_index);
 				upcase_table[col_index] = kmalloc_array(UTBL_ROW_COUNT,
 									sizeof(u16),
 									GFP_KERNEL);
-				if (upcase_table[col_index] == NULL) {
+				if (!upcase_table[col_index]) {
 					ret = FFS_MEMORYERR;
 					goto error;
 				}
@@ -873,10 +872,10 @@ s32 load_upcase_table(struct super_block *sb)
 				continue;
 
 			tbl_clu  = GET32_A(ep->start_clu);
-			tbl_size = (u32) GET64_A(ep->size);
+			tbl_size = (u32)GET64_A(ep->size);
 
 			sector = START_SECTOR(tbl_clu);
-			num_sectors = ((tbl_size-1) >> p_bd->sector_size_bits) + 1;
+			num_sectors = ((tbl_size - 1) >> p_bd->sector_size_bits) + 1;
 			if (__load_upcase_table(sb, sector, num_sectors,
 						GET32_A(ep->checksum)) != FFS_SUCCESS)
 				break;
@@ -909,7 +908,7 @@ void free_upcase_table(struct super_block *sb)
 
 u32 fat_get_entry_type(struct dentry_t *p_entry)
 {
-	struct dos_dentry_t *ep = (struct dos_dentry_t *) p_entry;
+	struct dos_dentry_t *ep = (struct dos_dentry_t *)p_entry;
 
 	if (*(ep->name) == 0x0)
 		return TYPE_UNUSED;
@@ -920,10 +919,10 @@ u32 fat_get_entry_type(struct dentry_t *p_entry)
 	else if (ep->attr == ATTR_EXTEND)
 		return TYPE_EXTEND;
 
-	else if ((ep->attr & (ATTR_SUBDIR|ATTR_VOLUME)) == ATTR_VOLUME)
+	else if ((ep->attr & (ATTR_SUBDIR | ATTR_VOLUME)) == ATTR_VOLUME)
 		return TYPE_VOLUME;
 
-	else if ((ep->attr & (ATTR_SUBDIR|ATTR_VOLUME)) == ATTR_SUBDIR)
+	else if ((ep->attr & (ATTR_SUBDIR | ATTR_VOLUME)) == ATTR_SUBDIR)
 		return TYPE_DIR;
 
 	return TYPE_FILE;
@@ -931,7 +930,7 @@ u32 fat_get_entry_type(struct dentry_t *p_entry)
 
 u32 exfat_get_entry_type(struct dentry_t *p_entry)
 {
-	struct file_dentry_t *ep = (struct file_dentry_t *) p_entry;
+	struct file_dentry_t *ep = (struct file_dentry_t *)p_entry;
 
 	if (ep->type == 0x0) {
 		return TYPE_UNUSED;
@@ -976,7 +975,7 @@ u32 exfat_get_entry_type(struct dentry_t *p_entry)
 
 void fat_set_entry_type(struct dentry_t *p_entry, u32 type)
 {
-	struct dos_dentry_t *ep = (struct dos_dentry_t *) p_entry;
+	struct dos_dentry_t *ep = (struct dos_dentry_t *)p_entry;
 
 	if (type == TYPE_UNUSED)
 		*(ep->name) = 0x0;
@@ -999,7 +998,7 @@ void fat_set_entry_type(struct dentry_t *p_entry, u32 type)
 
 void exfat_set_entry_type(struct dentry_t *p_entry, u32 type)
 {
-	struct file_dentry_t *ep = (struct file_dentry_t *) p_entry;
+	struct file_dentry_t *ep = (struct file_dentry_t *)p_entry;
 
 	if (type == TYPE_UNUSED) {
 		ep->type = 0x0;
@@ -1029,30 +1028,30 @@ void exfat_set_entry_type(struct dentry_t *p_entry, u32 type)
 
 u32 fat_get_entry_attr(struct dentry_t *p_entry)
 {
-	struct dos_dentry_t *ep = (struct dos_dentry_t *) p_entry;
+	struct dos_dentry_t *ep = (struct dos_dentry_t *)p_entry;
 
-	return (u32) ep->attr;
+	return (u32)ep->attr;
 }
 
 u32 exfat_get_entry_attr(struct dentry_t *p_entry)
 {
-	struct file_dentry_t *ep = (struct file_dentry_t *) p_entry;
+	struct file_dentry_t *ep = (struct file_dentry_t *)p_entry;
 
-	return (u32) GET16_A(ep->attr);
+	return (u32)GET16_A(ep->attr);
 }
 
 void fat_set_entry_attr(struct dentry_t *p_entry, u32 attr)
 {
-	struct dos_dentry_t *ep = (struct dos_dentry_t *) p_entry;
+	struct dos_dentry_t *ep = (struct dos_dentry_t *)p_entry;
 
-	ep->attr = (u8) attr;
+	ep->attr = (u8)attr;
 }
 
 void exfat_set_entry_attr(struct dentry_t *p_entry, u32 attr)
 {
-	struct file_dentry_t *ep = (struct file_dentry_t *) p_entry;
+	struct file_dentry_t *ep = (struct file_dentry_t *)p_entry;
 
-	SET16_A(ep->attr, (u16) attr);
+	SET16_A(ep->attr, (u16)attr);
 }
 
 u8 fat_get_entry_flag(struct dentry_t *p_entry)
@@ -1062,7 +1061,7 @@ u8 fat_get_entry_flag(struct dentry_t *p_entry)
 
 u8 exfat_get_entry_flag(struct dentry_t *p_entry)
 {
-	struct strm_dentry_t *ep = (struct strm_dentry_t *) p_entry;
+	struct strm_dentry_t *ep = (struct strm_dentry_t *)p_entry;
 
 	return ep->flags;
 }
@@ -1073,14 +1072,14 @@ void fat_set_entry_flag(struct dentry_t *p_entry, u8 flags)
 
 void exfat_set_entry_flag(struct dentry_t *p_entry, u8 flags)
 {
-	struct strm_dentry_t *ep = (struct strm_dentry_t *) p_entry;
+	struct strm_dentry_t *ep = (struct strm_dentry_t *)p_entry;
 
 	ep->flags = flags;
 }
 
 u32 fat_get_entry_clu0(struct dentry_t *p_entry)
 {
-	struct dos_dentry_t *ep = (struct dos_dentry_t *) p_entry;
+	struct dos_dentry_t *ep = (struct dos_dentry_t *)p_entry;
 
 	return ((u32)GET16_A(ep->start_clu_hi) << 16) |
 		GET16_A(ep->start_clu_lo);
@@ -1088,7 +1087,7 @@ u32 fat_get_entry_clu0(struct dentry_t *p_entry)
 
 u32 exfat_get_entry_clu0(struct dentry_t *p_entry)
 {
-	struct strm_dentry_t *ep = (struct strm_dentry_t *) p_entry;
+	struct strm_dentry_t *ep = (struct strm_dentry_t *)p_entry;
 
 	return GET32_A(ep->start_clu);
 }
@@ -1112,7 +1111,7 @@ u64 fat_get_entry_size(struct dentry_t *p_entry)
 {
 	struct dos_dentry_t *ep = (struct dos_dentry_t *)p_entry;
 
-	return (u64) GET32_A(ep->size);
+	return (u64)GET32_A(ep->size);
 }
 
 u64 exfat_get_entry_size(struct dentry_t *p_entry)
@@ -1126,7 +1125,7 @@ void fat_set_entry_size(struct dentry_t *p_entry, u64 size)
 {
 	struct dos_dentry_t *ep = (struct dos_dentry_t *)p_entry;
 
-	SET32_A(ep->size, (u32) size);
+	SET32_A(ep->size, (u32)size);
 }
 
 void exfat_set_entry_size(struct dentry_t *p_entry, u64 size)
@@ -1270,7 +1269,7 @@ s32 exfat_init_dir_entry(struct super_block *sb, struct chain_t *p_dir,
 	if (!file_ep)
 		return FFS_MEDIAERR;
 
-	strm_ep = (struct strm_dentry_t *)get_entry_in_dir(sb, p_dir, entry+1,
+	strm_ep = (struct strm_dentry_t *)get_entry_in_dir(sb, p_dir, entry + 1,
 							   &sector);
 	if (!strm_ep)
 		return FFS_MEDIAERR;
@@ -1328,7 +1327,7 @@ static s32 fat_init_ext_entry(struct super_block *sb, struct chain_t *p_dir,
 		if (!ext_ep)
 			return FFS_MEDIAERR;
 
-		init_ext_entry(ext_ep, i+0x40, chksum, uniname);
+		init_ext_entry(ext_ep, i + 0x40, chksum, uniname);
 		buf_modify(sb, sector);
 	}
 
@@ -1355,7 +1354,7 @@ static s32 exfat_init_ext_entry(struct super_block *sb, struct chain_t *p_dir,
 	file_ep->num_ext = (u8)(num_entries - 1);
 	buf_modify(sb, sector);
 
-	strm_ep = (struct strm_dentry_t *)get_entry_in_dir(sb, p_dir, entry+1,
+	strm_ep = (struct strm_dentry_t *)get_entry_in_dir(sb, p_dir, entry + 1,
 							   &sector);
 	if (!strm_ep)
 		return FFS_MEDIAERR;
@@ -1385,14 +1384,14 @@ void init_dos_entry(struct dos_dentry_t *ep, u32 type, u32 start_clu)
 {
 	struct timestamp_t tm, *tp;
 
-	fat_set_entry_type((struct dentry_t *) ep, type);
+	fat_set_entry_type((struct dentry_t *)ep, type);
 	SET16_A(ep->start_clu_lo, CLUSTER_16(start_clu));
 	SET16_A(ep->start_clu_hi, CLUSTER_16(start_clu >> 16));
 	SET32_A(ep->size, 0);
 
 	tp = tm_current(&tm);
-	fat_set_entry_time((struct dentry_t *) ep, tp, TM_CREATE);
-	fat_set_entry_time((struct dentry_t *) ep, tp, TM_MODIFY);
+	fat_set_entry_time((struct dentry_t *)ep, tp, TM_CREATE);
+	fat_set_entry_time((struct dentry_t *)ep, tp, TM_MODIFY);
 	SET16_A(ep->access_date, 0);
 	ep->create_time_ms = 0;
 }
@@ -1400,23 +1399,23 @@ void init_dos_entry(struct dos_dentry_t *ep, u32 type, u32 start_clu)
 void init_ext_entry(struct ext_dentry_t *ep, s32 order, u8 chksum, u16 *uniname)
 {
 	int i;
-	u8 end = FALSE;
+	bool end = false;
 
-	fat_set_entry_type((struct dentry_t *) ep, TYPE_EXTEND);
-	ep->order = (u8) order;
+	fat_set_entry_type((struct dentry_t *)ep, TYPE_EXTEND);
+	ep->order = (u8)order;
 	ep->sysid = 0;
 	ep->checksum = chksum;
 	SET16_A(ep->start_clu, 0);
 
 	for (i = 0; i < 10; i += 2) {
 		if (!end) {
-			SET16(ep->unicode_0_4+i, *uniname);
+			SET16(ep->unicode_0_4 + i, *uniname);
 			if (*uniname == 0x0)
-				end = TRUE;
+				end = true;
 			else
 				uniname++;
 		} else {
-			SET16(ep->unicode_0_4+i, 0xFFFF);
+			SET16(ep->unicode_0_4 + i, 0xFFFF);
 		}
 	}
 
@@ -1424,7 +1423,7 @@ void init_ext_entry(struct ext_dentry_t *ep, s32 order, u8 chksum, u16 *uniname)
 		if (!end) {
 			SET16_A(ep->unicode_5_10 + i, *uniname);
 			if (*uniname == 0x0)
-				end = TRUE;
+				end = true;
 			else
 				uniname++;
 		} else {
@@ -1436,7 +1435,7 @@ void init_ext_entry(struct ext_dentry_t *ep, s32 order, u8 chksum, u16 *uniname)
 		if (!end) {
 			SET16_A(ep->unicode_11_12 + i, *uniname);
 			if (*uniname == 0x0)
-				end = TRUE;
+				end = true;
 			else
 				uniname++;
 		} else {
@@ -1477,7 +1476,7 @@ void init_name_entry(struct name_dentry_t *ep, u16 *uniname)
 	ep->flags = 0x0;
 
 	for (i = 0; i < 30; i++, i++) {
-		SET16_A(ep->unicode_0_14+i, *uniname);
+		SET16_A(ep->unicode_0_14 + i, *uniname);
 		if (*uniname == 0x0)
 			break;
 		uniname++;
@@ -1492,8 +1491,8 @@ void fat_delete_dir_entry(struct super_block *sb, struct chain_t *p_dir,
 	struct dentry_t *ep;
 	struct fs_info_t *p_fs = &(EXFAT_SB(sb)->fs_info);
 
-	for (i = num_entries-1; i >= order; i--) {
-		ep = get_entry_in_dir(sb, p_dir, entry-i, &sector);
+	for (i = num_entries - 1; i >= order; i--) {
+		ep = get_entry_in_dir(sb, p_dir, entry - i, &sector);
 		if (!ep)
 			return;
 
@@ -1511,7 +1510,7 @@ void exfat_delete_dir_entry(struct super_block *sb, struct chain_t *p_dir,
 	struct fs_info_t *p_fs = &(EXFAT_SB(sb)->fs_info);
 
 	for (i = order; i < num_entries; i++) {
-		ep = get_entry_in_dir(sb, p_dir, entry+i, &sector);
+		ep = get_entry_in_dir(sb, p_dir, entry + i, &sector);
 		if (!ep)
 			return;
 
@@ -1536,12 +1535,12 @@ void update_dir_checksum(struct super_block *sb, struct chain_t *p_dir,
 
 	buf_lock(sb, sector);
 
-	num_entries = (s32) file_ep->num_ext + 1;
+	num_entries = (s32)file_ep->num_ext + 1;
 	chksum = calc_checksum_2byte((void *)file_ep, DENTRY_SIZE, 0,
 				     CS_DIR_ENTRY);
 
 	for (i = 1; i < num_entries; i++) {
-		ep = get_entry_in_dir(sb, p_dir, entry+i, NULL);
+		ep = get_entry_in_dir(sb, p_dir, entry + i, NULL);
 		if (!ep) {
 			buf_unlock(sb, sector);
 			return;
@@ -1641,7 +1640,7 @@ struct dentry_t *get_entry_with_sector(struct super_block *sb, sector_t sector,
 
 	buf = buf_getblk(sb, sector);
 
-	if (buf == NULL)
+	if (!buf)
 		return NULL;
 
 	return (struct dentry_t *)(buf + offset);
@@ -1659,10 +1658,10 @@ struct dentry_t *get_entry_in_dir(struct super_block *sb, struct chain_t *p_dir,
 
 	buf = buf_getblk(sb, sec);
 
-	if (buf == NULL)
+	if (!buf)
 		return NULL;
 
-	if (sector != NULL)
+	if (sector)
 		*sector = sec;
 	return (struct dentry_t *)(buf + off);
 }
@@ -1711,7 +1710,6 @@ struct entry_set_cache_t *get_entry_set_in_dir(struct super_block *sb,
 	if (ret != FFS_SUCCESS)
 		return NULL;
 
-
 	/* byte offset in cluster */
 	byte_offset &= p_fs->cluster_size - 1;
 
@@ -1723,10 +1721,9 @@ struct entry_set_cache_t *get_entry_set_in_dir(struct super_block *sb,
 	sec += START_SECTOR(clu);
 
 	buf = buf_getblk(sb, sec);
-	if (buf == NULL)
+	if (!buf)
 		goto err_out;
 
-
 	ep = (struct dentry_t *)(buf + off);
 	entry_type = p_fs->fs_func->get_entry_type(ep);
 
@@ -1735,7 +1732,7 @@ struct entry_set_cache_t *get_entry_set_in_dir(struct super_block *sb,
 		goto err_out;
 
 	if (type == ES_ALL_ENTRIES)
-		num_entries = ((struct file_dentry_t *)ep)->num_ext+1;
+		num_entries = ((struct file_dentry_t *)ep)->num_ext + 1;
 	else
 		num_entries = type;
 
@@ -1744,7 +1741,7 @@ struct entry_set_cache_t *get_entry_set_in_dir(struct super_block *sb,
 	pr_debug("%s: trying to kmalloc %zx bytes for %d entries\n", __func__,
 		 bufsize, num_entries);
 	es = kmalloc(bufsize, GFP_KERNEL);
-	if (es == NULL)
+	if (!es)
 		goto err_out;
 
 	es->num_entries = num_entries;
@@ -1752,12 +1749,12 @@ struct entry_set_cache_t *get_entry_set_in_dir(struct super_block *sb,
 	es->offset = off;
 	es->alloc_flag = p_dir->flags;
 
-	pos = (struct dentry_t *) &(es->__buf);
+	pos = (struct dentry_t *)&es->__buf;
 
 	while (num_entries) {
 		/*
 		 * instead of copying whole sector, we will check every entry.
-		 * this will provide minimum stablity and consistancy.
+		 * this will provide minimum stablity and consistency.
 		 */
 		entry_type = p_fs->fs_func->get_entry_type(ep);
 
@@ -1823,7 +1820,7 @@ struct entry_set_cache_t *get_entry_set_in_dir(struct super_block *sb,
 				sec++;
 			}
 			buf = buf_getblk(sb, sec);
-			if (buf == NULL)
+			if (!buf)
 				goto err_out;
 			off = 0;
 			ep = (struct dentry_t *)(buf);
@@ -1853,7 +1850,6 @@ void release_entry_set(struct entry_set_cache_t *es)
 	kfree(es);
 }
 
-
 static s32 __write_partial_entries_in_entry_set(struct super_block *sb,
 						struct entry_set_cache_t *es,
 						sector_t sec, s32 off, u32 count)
@@ -1876,7 +1872,7 @@ static s32 __write_partial_entries_in_entry_set(struct super_block *sb,
 				     remaining_byte_in_sector >> DENTRY_SIZE_BITS,
 				     num_entries);
 		buf = buf_getblk(sb, sec);
-		if (buf == NULL)
+		if (!buf)
 			goto err_out;
 		pr_debug("es->buf %p buf_off %u\n", esbuf, buf_off);
 		pr_debug("copying %d entries from %p to sector %llu\n",
@@ -2002,7 +1998,7 @@ s32 search_deleted_or_unused_entry(struct super_block *sb,
 		if (p_dir->dir == CLUSTER_32(0)) /* FAT16 root_dir */
 			i = dentry % dentries_per_clu;
 		else
-			i = dentry & (dentries_per_clu-1);
+			i = dentry & (dentries_per_clu - 1);
 
 		for (; i < dentries_per_clu; i++, dentry++) {
 			ep = get_entry_in_dir(sb, &clu, i, NULL);
@@ -2032,7 +2028,7 @@ s32 search_deleted_or_unused_entry(struct super_block *sb,
 				p_fs->hint_uentry.entry = -1;
 
 				if (p_fs->vol_type == EXFAT)
-					return dentry - (num_entries-1);
+					return dentry - (num_entries - 1);
 				else
 					return dentry;
 			}
@@ -2131,7 +2127,7 @@ s32 find_empty_entry(struct inode *inode, struct chain_t *p_dir, s32 num_entries
 			}
 		}
 
-		i_size_write(inode, i_size_read(inode)+p_fs->cluster_size);
+		i_size_write(inode, i_size_read(inode) + p_fs->cluster_size);
 		EXFAT_I(inode)->mmu_private += p_fs->cluster_size;
 		EXFAT_I(inode)->fid.size += p_fs->cluster_size;
 		EXFAT_I(inode)->fid.flags = p_dir->flags;
@@ -2150,8 +2146,9 @@ s32 fat_find_dir_entry(struct super_block *sb, struct chain_t *p_dir,
 		       struct uni_name_t *p_uniname, s32 num_entries,
 		       struct dos_name_t *p_dosname, u32 type)
 {
-	int i, dentry = 0, lossy = FALSE, len;
-	s32 order = 0, is_feasible_entry = TRUE, has_ext_entry = FALSE;
+	int i, dentry = 0, len;
+	s32 order = 0;
+	bool is_feasible_entry = true, has_ext_entry = false;
 	s32 dentries_per_clu;
 	u32 entry_type;
 	u16 entry_uniname[14], *uniname = NULL, unichar;
@@ -2193,39 +2190,39 @@ s32 fat_find_dir_entry(struct super_block *sb, struct chain_t *p_dir,
 					if (is_feasible_entry && has_ext_entry)
 						return dentry;
 
-					dos_ep = (struct dos_dentry_t *) ep;
-					if ((!lossy) && (!nls_dosname_cmp(sb, p_dosname->name, dos_ep->name)))
+					dos_ep = (struct dos_dentry_t *)ep;
+					if (!nls_dosname_cmp(sb, p_dosname->name, dos_ep->name))
 						return dentry;
 				}
-				is_feasible_entry = TRUE;
-				has_ext_entry = FALSE;
+				is_feasible_entry = true;
+				has_ext_entry = false;
 			} else if (entry_type == TYPE_EXTEND) {
 				if (is_feasible_entry) {
-					ext_ep = (struct ext_dentry_t *) ep;
+					ext_ep = (struct ext_dentry_t *)ep;
 					if (ext_ep->order > 0x40) {
 						order = (s32)(ext_ep->order - 0x40);
-						uniname = p_uniname->name + 13 * (order-1);
+						uniname = p_uniname->name + 13 * (order - 1);
 					} else {
-						order = (s32) ext_ep->order;
+						order = (s32)ext_ep->order;
 						uniname -= 13;
 					}
 
 					len = extract_uni_name_from_ext_entry(ext_ep, entry_uniname, order);
 
-					unichar = *(uniname+len);
-					*(uniname+len) = 0x0;
+					unichar = *(uniname + len);
+					*(uniname + len) = 0x0;
 
 					if (nls_uniname_cmp(sb, uniname, entry_uniname))
-						is_feasible_entry = FALSE;
+						is_feasible_entry = false;
 
-					*(uniname+len) = unichar;
+					*(uniname + len) = unichar;
 				}
-				has_ext_entry = TRUE;
+				has_ext_entry = true;
 			} else if (entry_type == TYPE_UNUSED) {
 				return -2;
 			}
-			is_feasible_entry = TRUE;
-			has_ext_entry = FALSE;
+			is_feasible_entry = true;
+			has_ext_entry = false;
 		}
 
 		if (p_dir->dir == CLUSTER_32(0))
@@ -2248,7 +2245,8 @@ s32 exfat_find_dir_entry(struct super_block *sb, struct chain_t *p_dir,
 			 struct dos_name_t *p_dosname, u32 type)
 {
 	int i = 0, dentry = 0, num_ext_entries = 0, len, step;
-	s32 order = 0, is_feasible_entry = FALSE;
+	s32 order = 0;
+	bool is_feasible_entry = false;
 	s32 dentries_per_clu, num_empty = 0;
 	u32 entry_type;
 	u16 entry_uniname[16], *uniname = NULL, unichar;
@@ -2292,7 +2290,7 @@ s32 exfat_find_dir_entry(struct super_block *sb, struct chain_t *p_dir,
 			step = 1;
 
 			if ((entry_type == TYPE_UNUSED) || (entry_type == TYPE_DELETED)) {
-				is_feasible_entry = FALSE;
+				is_feasible_entry = false;
 
 				if (p_fs->hint_uentry.entry == -1) {
 					num_empty++;
@@ -2303,7 +2301,7 @@ s32 exfat_find_dir_entry(struct super_block *sb, struct chain_t *p_dir,
 						p_fs->hint_uentry.clu.flags = clu.flags;
 					}
 					if ((num_empty >= num_entries) || (entry_type == TYPE_UNUSED))
-						p_fs->hint_uentry.entry = dentry - (num_empty-1);
+						p_fs->hint_uentry.entry = dentry - (num_empty - 1);
 				}
 
 				if (entry_type == TYPE_UNUSED)
@@ -2312,12 +2310,12 @@ s32 exfat_find_dir_entry(struct super_block *sb, struct chain_t *p_dir,
 				num_empty = 0;
 
 				if ((entry_type == TYPE_FILE) || (entry_type == TYPE_DIR)) {
-					file_ep = (struct file_dentry_t *) ep;
+					file_ep = (struct file_dentry_t *)ep;
 					if ((type == TYPE_ALL) || (type == entry_type)) {
 						num_ext_entries = file_ep->num_ext;
-						is_feasible_entry = TRUE;
+						is_feasible_entry = true;
 					} else {
-						is_feasible_entry = FALSE;
+						is_feasible_entry = false;
 						step = file_ep->num_ext + 1;
 					}
 				} else if (entry_type == TYPE_STREAM) {
@@ -2327,7 +2325,7 @@ s32 exfat_find_dir_entry(struct super_block *sb, struct chain_t *p_dir,
 						    p_uniname->name_len == strm_ep->name_len) {
 							order = 1;
 						} else {
-							is_feasible_entry = FALSE;
+							is_feasible_entry = false;
 							step = num_ext_entries;
 						}
 					}
@@ -2343,11 +2341,11 @@ s32 exfat_find_dir_entry(struct super_block *sb, struct chain_t *p_dir,
 						len = extract_uni_name_from_name_entry(name_ep,
 								entry_uniname, order);
 
-						unichar = *(uniname+len);
-						*(uniname+len) = 0x0;
+						unichar = *(uniname + len);
+						*(uniname + len) = 0x0;
 
 						if (nls_uniname_cmp(sb, uniname, entry_uniname)) {
-							is_feasible_entry = FALSE;
+							is_feasible_entry = false;
 							step = num_ext_entries - order + 1;
 						} else if (order == num_ext_entries) {
 							p_fs->hint_uentry.dir = CLUSTER_32(~0);
@@ -2355,10 +2353,10 @@ s32 exfat_find_dir_entry(struct super_block *sb, struct chain_t *p_dir,
 							return dentry - (num_ext_entries);
 						}
 
-						*(uniname+len) = unichar;
+						*(uniname + len) = unichar;
 					}
 				} else {
-					is_feasible_entry = FALSE;
+					is_feasible_entry = false;
 				}
 			}
 
@@ -2390,11 +2388,11 @@ s32 fat_count_ext_entries(struct super_block *sb, struct chain_t *p_dir,
 {
 	s32 count = 0;
 	u8 chksum;
-	struct dos_dentry_t *dos_ep = (struct dos_dentry_t *) p_entry;
+	struct dos_dentry_t *dos_ep = (struct dos_dentry_t *)p_entry;
 	struct ext_dentry_t *ext_ep;
 	struct fs_info_t *p_fs = &(EXFAT_SB(sb)->fs_info);
 
-	chksum = calc_checksum_1byte((void *) dos_ep->name, DOS_NAME_LENGTH, 0);
+	chksum = calc_checksum_1byte((void *)dos_ep->name, DOS_NAME_LENGTH, 0);
 
 	for (entry--; entry >= 0; entry--) {
 		ext_ep = (struct ext_dentry_t *)get_entry_in_dir(sb, p_dir,
@@ -2526,17 +2524,17 @@ bool is_dir_empty(struct super_block *sb, struct chain_t *p_dir)
 			type = p_fs->fs_func->get_entry_type(ep);
 
 			if (type == TYPE_UNUSED)
-				return TRUE;
+				return true;
 			if ((type != TYPE_FILE) && (type != TYPE_DIR))
 				continue;
 
 			if (p_dir->dir == CLUSTER_32(0)) /* FAT16 root_dir */
-				return FALSE;
+				return false;
 
 			if (p_fs->vol_type == EXFAT)
-				return FALSE;
+				return false;
 			if ((p_dir->dir == p_fs->root_dir) || ((++count) > 2))
-				return FALSE;
+				return false;
 		}
 
 		if (p_dir->dir == CLUSTER_32(0))
@@ -2552,7 +2550,7 @@ bool is_dir_empty(struct super_block *sb, struct chain_t *p_dir)
 			break;
 	}
 
-	return TRUE;
+	return true;
 }
 
 /*
@@ -2653,7 +2651,7 @@ void exfat_get_uni_name_from_ext_entry(struct super_block *sb,
 	struct fs_info_t *p_fs = &(EXFAT_SB(sb)->fs_info);
 
 	es = get_entry_set_in_dir(sb, p_dir, entry, ES_ALL_ENTRIES, &ep);
-	if (es == NULL || es->num_entries < 3) {
+	if (!es || es->num_entries < 3) {
 		if (es)
 			release_entry_set(es);
 		return;
@@ -2745,7 +2743,8 @@ s32 extract_uni_name_from_name_entry(struct name_dentry_t *ep, u16 *uniname,
 s32 fat_generate_dos_name(struct super_block *sb, struct chain_t *p_dir,
 			  struct dos_name_t *p_dosname)
 {
-	int i, j, count = 0, count_begin = FALSE;
+	int i, j, count = 0;
+	bool count_begin = false;
 	s32 dentries_per_clu;
 	u32 type;
 	u8 bmap[128/* 1 ~ 1023 */];
@@ -2783,14 +2782,14 @@ s32 fat_generate_dos_name(struct super_block *sb, struct chain_t *p_dir,
 				continue;
 
 			count = 0;
-			count_begin = FALSE;
+			count_begin = false;
 
 			for (j = 0; j < 8; j++) {
 				if (ep->name[j] == ' ')
 					break;
 
 				if (ep->name[j] == '~') {
-					count_begin = TRUE;
+					count_begin = true;
 				} else if (count_begin) {
 					if ((ep->name[j] >= '0') &&
 					    (ep->name[j] <= '9')) {
@@ -2798,7 +2797,7 @@ s32 fat_generate_dos_name(struct super_block *sb, struct chain_t *p_dir,
 							(ep->name[j] - '0');
 					} else {
 						count = 0;
-						count_begin = FALSE;
+						count_begin = false;
 					}
 				}
 			}
@@ -2962,11 +2961,9 @@ s32 resolve_path(struct inode *inode, char *path, struct chain_t *p_dir,
 	struct fs_info_t *p_fs = &(EXFAT_SB(sb)->fs_info);
 	struct file_id_t *fid = &(EXFAT_I(inode)->fid);
 
-	if (strlen(path) >= (MAX_NAME_LENGTH * MAX_CHARSET_SIZE))
+	if (strscpy(name_buf, path, sizeof(name_buf)) < 0)
 		return FFS_INVALIDPATH;
 
-	strcpy(name_buf, path);
-
 	nls_cstring_to_uniname(sb, p_uniname, name_buf, &lossy);
 	if (lossy)
 		return FFS_INVALIDPATH;
@@ -3065,7 +3062,7 @@ s32 fat16_mount(struct super_block *sb, struct pbr_sector_t *p_pbr)
 
 	p_fs->vol_flag = VOL_CLEAN;
 	p_fs->clu_srch_ptr = 2;
-	p_fs->used_clusters = (u32)~0;
+	p_fs->used_clusters = UINT_MAX;
 
 	p_fs->fs_func = &fat_fs_func;
 
@@ -3118,7 +3115,7 @@ s32 fat32_mount(struct super_block *sb, struct pbr_sector_t *p_pbr)
 
 	p_fs->vol_flag = VOL_CLEAN;
 	p_fs->clu_srch_ptr = 2;
-	p_fs->used_clusters = (u32)~0;
+	p_fs->used_clusters = UINT_MAX;
 
 	p_fs->fs_func = &fat_fs_func;
 
@@ -3193,7 +3190,7 @@ s32 exfat_mount(struct super_block *sb, struct pbr_sector_t *p_pbr)
 
 	p_fs->vol_flag = (u32)GET16(p_bpb->vol_flags);
 	p_fs->clu_srch_ptr = 2;
-	p_fs->used_clusters = (u32)~0;
+	p_fs->used_clusters = UINT_MAX;
 
 	p_fs->fs_func = &exfat_fs_func;
 
@@ -3617,7 +3614,7 @@ int sector_read(struct super_block *sb, sector_t sec, struct buffer_head **bh,
 	if (!p_fs->dev_ejected) {
 		ret = bdev_read(sb, sec, bh, 1, read);
 		if (ret != FFS_SUCCESS)
-			p_fs->dev_ejected = TRUE;
+			p_fs->dev_ejected = 1;
 	}
 
 	return ret;
@@ -3646,7 +3643,7 @@ int sector_write(struct super_block *sb, sector_t sec, struct buffer_head *bh,
 	if (!p_fs->dev_ejected) {
 		ret = bdev_write(sb, sec, bh, 1, sync);
 		if (ret != FFS_SUCCESS)
-			p_fs->dev_ejected = TRUE;
+			p_fs->dev_ejected = 1;
 	}
 
 	return ret;
@@ -3669,7 +3666,7 @@ int multi_sector_read(struct super_block *sb, sector_t sec,
 	if (!p_fs->dev_ejected) {
 		ret = bdev_read(sb, sec, bh, num_secs, read);
 		if (ret != FFS_SUCCESS)
-			p_fs->dev_ejected = TRUE;
+			p_fs->dev_ejected = 1;
 	}
 
 	return ret;
@@ -3697,7 +3694,7 @@ int multi_sector_write(struct super_block *sb, sector_t sec,
 	if (!p_fs->dev_ejected) {
 		ret = bdev_write(sb, sec, bh, num_secs, sync);
 		if (ret != FFS_SUCCESS)
-			p_fs->dev_ejected = TRUE;
+			p_fs->dev_ejected = 1;
 	}
 
 	return ret;
diff --git a/drivers/staging/exfat/exfat_nls.c b/drivers/staging/exfat/exfat_nls.c
index 2ca58616159b..03cb8290b5d2 100644
--- a/drivers/staging/exfat/exfat_nls.c
+++ b/drivers/staging/exfat/exfat_nls.c
@@ -225,7 +225,7 @@ void nls_uniname_to_dosname(struct super_block *sb,
 		*dosname = 0x05;
 
 	if (*uniname != 0x0)
-		lossy = TRUE;
+		lossy = true;
 
 	if (upper & lower)
 		p_dosname->name_case = 0xFF;
diff --git a/drivers/staging/exfat/exfat_super.c b/drivers/staging/exfat/exfat_super.c
index 5b5c2ca8c9aa..5f6caee819a6 100644
--- a/drivers/staging/exfat/exfat_super.c
+++ b/drivers/staging/exfat/exfat_super.c
@@ -3,7 +3,6 @@
  *  Copyright (C) 2012-2013 Samsung Electronics Co., Ltd.
  */
 
-#include <linux/version.h>
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/time.h>
@@ -26,7 +25,6 @@
 #include <linux/sched.h>
 #include <linux/fs_struct.h>
 #include <linux/namei.h>
-#include <linux/time.h>
 
 #include <linux/string.h>
 #include <linux/nls.h>
@@ -39,11 +37,8 @@
 
 static struct kmem_cache *exfat_inode_cachep;
 
-// FIXME use commented lines
-// static int exfat_default_codepage = CONFIG_EXFAT_DEFAULT_CODEPAGE;
-// static char exfat_default_iocharset[] = CONFIG_EXFAT_DEFAULT_IOCHARSET;
-static int exfat_default_codepage = CONFIG_FAT_DEFAULT_CODEPAGE;
-static char exfat_default_iocharset[] = CONFIG_FAT_DEFAULT_IOCHARSET;
+static int exfat_default_codepage = CONFIG_EXFAT_DEFAULT_CODEPAGE;
+static char exfat_default_iocharset[] = CONFIG_EXFAT_DEFAULT_IOCHARSET;
 
 #define INC_IVERSION(x) (inode_inc_iversion(x))
 #define GET_IVERSION(x) (inode_peek_iversion_raw(x))
@@ -58,129 +53,63 @@ static int exfat_write_inode(struct inode *inode,
 static void exfat_write_super(struct super_block *sb);
 
 #define UNIX_SECS_1980    315532800L
-
-#if BITS_PER_LONG == 64
 #define UNIX_SECS_2108    4354819200L
-#endif
-
-/* days between 1.1.70 and 1.1.80 (2 leap days) */
-#define DAYS_DELTA_DECADE    (365 * 10 + 2)
-/* 120 (2100 - 1980) isn't leap year */
-#define NO_LEAP_YEAR_2100    (120)
-#define IS_LEAP_YEAR(y)    (!((y) & 0x3) && (y) != NO_LEAP_YEAR_2100)
-
-#define SECS_PER_MIN    (60)
-#define SECS_PER_HOUR   (60 * SECS_PER_MIN)
-#define SECS_PER_DAY    (24 * SECS_PER_HOUR)
-
-#define MAKE_LEAP_YEAR(leap_year, year)                         \
-	do {                                                    \
-		if (unlikely(year > NO_LEAP_YEAR_2100))         \
-			leap_year = ((year + 3) / 4) - 1;       \
-		else                                            \
-			leap_year = ((year + 3) / 4);           \
-	} while (0)
-
-/* Linear day numbers of the respective 1sts in non-leap years. */
-static time_t accum_days_in_year[] = {
-	/* Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov  Dec */
-	0,   0,  31,  59,  90, 120, 151, 181, 212, 243, 273, 304, 334, 0, 0, 0,
-};
 
 /* Convert a FAT time/date pair to a UNIX date (seconds since 1 1 70). */
-static void exfat_time_fat2unix(struct exfat_sb_info *sbi,
-				struct timespec64 *ts, struct date_time_t *tp)
+static void exfat_time_fat2unix(struct timespec64 *ts, struct date_time_t *tp)
 {
-	time_t year = tp->Year;
-	time_t ld;
-
-	MAKE_LEAP_YEAR(ld, year);
-
-	if (IS_LEAP_YEAR(year) && (tp->Month) > 2)
-		ld++;
+	ts->tv_sec = mktime64(tp->Year + 1980, tp->Month + 1, tp->Day,
+			      tp->Hour, tp->Minute, tp->Second);
 
-	ts->tv_sec = tp->Second +
-		     tp->Minute * SECS_PER_MIN +
-		     tp->Hour * SECS_PER_HOUR +
-		     (ld + accum_days_in_year[(tp->Month)] +
-		      (tp->Day - 1)) * SECS_PER_DAY +
-		     (year * 365 + DAYS_DELTA_DECADE) * SECS_PER_DAY +
-		     sys_tz.tz_minuteswest * SECS_PER_MIN;
-
-	ts->tv_nsec = 0;
+	ts->tv_nsec = tp->MilliSecond * NSEC_PER_MSEC;
 }
 
 /* Convert linear UNIX date to a FAT time/date pair. */
-static void exfat_time_unix2fat(struct exfat_sb_info *sbi,
-				struct timespec64 *ts, struct date_time_t *tp)
+static void exfat_time_unix2fat(struct timespec64 *ts, struct date_time_t *tp)
 {
-	time_t second = ts->tv_sec;
-	time_t day, month, year;
-	time_t ld;
+	time64_t second = ts->tv_sec;
+	struct tm tm;
 
-	second -= sys_tz.tz_minuteswest * SECS_PER_MIN;
+	time64_to_tm(second, 0, &tm);
 
-	/* Jan 1 GMT 00:00:00 1980. But what about another time zone? */
 	if (second < UNIX_SECS_1980) {
-		tp->Second  = 0;
-		tp->Minute  = 0;
-		tp->Hour = 0;
-		tp->Day  = 1;
-		tp->Month  = 1;
-		tp->Year = 0;
+		tp->MilliSecond = 0;
+		tp->Second	= 0;
+		tp->Minute	= 0;
+		tp->Hour	= 0;
+		tp->Day		= 1;
+		tp->Month	= 1;
+		tp->Year	= 0;
 		return;
 	}
-#if (BITS_PER_LONG == 64)
+
 	if (second >= UNIX_SECS_2108) {
-		tp->Second  = 59;
-		tp->Minute  = 59;
-		tp->Hour = 23;
-		tp->Day  = 31;
-		tp->Month  = 12;
-		tp->Year = 127;
+		tp->MilliSecond = 999;
+		tp->Second	= 59;
+		tp->Minute	= 59;
+		tp->Hour	= 23;
+		tp->Day		= 31;
+		tp->Month	= 12;
+		tp->Year	= 127;
 		return;
 	}
-#endif
-	day = second / SECS_PER_DAY - DAYS_DELTA_DECADE;
-	year = day / 365;
-	MAKE_LEAP_YEAR(ld, year);
-	if (year * 365 + ld > day)
-		year--;
-
-	MAKE_LEAP_YEAR(ld, year);
-	day -= year * 365 + ld;
 
-	if (IS_LEAP_YEAR(year) && day == accum_days_in_year[3]) {
-		month = 2;
-	} else {
-		if (IS_LEAP_YEAR(year) && day > accum_days_in_year[3])
-			day--;
-		for (month = 1; month < 12; month++) {
-			if (accum_days_in_year[month + 1] > day)
-				break;
-		}
-	}
-	day -= accum_days_in_year[month];
-
-	tp->Second  = second % SECS_PER_MIN;
-	tp->Minute  = (second / SECS_PER_MIN) % 60;
-	tp->Hour = (second / SECS_PER_HOUR) % 24;
-	tp->Day  = day + 1;
-	tp->Month  = month;
-	tp->Year = year;
+	tp->MilliSecond = ts->tv_nsec / NSEC_PER_MSEC;
+	tp->Second	= tm.tm_sec;
+	tp->Minute	= tm.tm_min;
+	tp->Hour	= tm.tm_hour;
+	tp->Day		= tm.tm_mday;
+	tp->Month	= tm.tm_mon + 1;
+	tp->Year	= tm.tm_year + 1900 - 1980;
 }
 
 struct timestamp_t *tm_current(struct timestamp_t *tp)
 {
-	struct timespec64 ts;
-	time_t second, day, leap_day, month, year;
-
-	ktime_get_real_ts64(&ts);
+	time64_t second = ktime_get_real_seconds();
+	struct tm tm;
 
-	second = ts.tv_sec;
-	second -= sys_tz.tz_minuteswest * SECS_PER_MIN;
+	time64_to_tm(second, 0, &tm);
 
-	/* Jan 1 GMT 00:00:00 1980. But what about another time zone? */
 	if (second < UNIX_SECS_1980) {
 		tp->sec  = 0;
 		tp->min  = 0;
@@ -190,7 +119,7 @@ struct timestamp_t *tm_current(struct timestamp_t *tp)
 		tp->year = 0;
 		return tp;
 	}
-#if BITS_PER_LONG == 64
+
 	if (second >= UNIX_SECS_2108) {
 		tp->sec  = 59;
 		tp->min  = 59;
@@ -200,37 +129,13 @@ struct timestamp_t *tm_current(struct timestamp_t *tp)
 		tp->year = 127;
 		return tp;
 	}
-#endif
-
-	day = second / SECS_PER_DAY - DAYS_DELTA_DECADE;
-	year = day / 365;
-
-	MAKE_LEAP_YEAR(leap_day, year);
-	if (year * 365 + leap_day > day)
-		year--;
-
-	MAKE_LEAP_YEAR(leap_day, year);
-
-	day -= year * 365 + leap_day;
-
-	if (IS_LEAP_YEAR(year) && day == accum_days_in_year[3]) {
-		month = 2;
-	} else {
-		if (IS_LEAP_YEAR(year) && day > accum_days_in_year[3])
-			day--;
-		for (month = 1; month < 12; month++) {
-			if (accum_days_in_year[month + 1] > day)
-				break;
-		}
-	}
-	day -= accum_days_in_year[month];
 
-	tp->sec  = second % SECS_PER_MIN;
-	tp->min  = (second / SECS_PER_MIN) % 60;
-	tp->hour = (second / SECS_PER_HOUR) % 24;
-	tp->day  = day + 1;
-	tp->mon  = month;
-	tp->year = year;
+	tp->sec  = tm.tm_sec;
+	tp->min  = tm.tm_min;
+	tp->hour = tm.tm_hour;
+	tp->day  = tm.tm_mday;
+	tp->mon  = tm.tm_mon + 1;
+	tp->year = tm.tm_year + 1900 - 1980;
 
 	return tp;
 }
@@ -341,11 +246,13 @@ static int exfat_cmpi(const struct dentry *dentry, unsigned int len,
 	alen = exfat_striptail_len(name);
 	blen = __exfat_striptail_len(len, str);
 	if (alen == blen) {
-		if (t == NULL) {
+		if (!t) {
 			if (strncasecmp(name->name, str, alen) == 0)
 				return 0;
-		} else if (nls_strnicmp(t, name->name, str, alen) == 0)
-			return 0;
+		} else {
+			if (nls_strnicmp(t, name->name, str, alen) == 0)
+				return 0;
+		}
 	}
 	return 1;
 }
@@ -450,7 +357,7 @@ static int ffsMountVol(struct super_block *sb)
 	buf_init(sb);
 
 	sema_init(&p_fs->v_sem, 1);
-	p_fs->dev_ejected = FALSE;
+	p_fs->dev_ejected = 0;
 
 	/* open the block device */
 	bdev_open(sb);
@@ -470,7 +377,7 @@ static int ffsMountVol(struct super_block *sb)
 
 	p_fs->PBR_sector = 0;
 
-	p_pbr = (struct pbr_sector_t *) tmp_bh->b_data;
+	p_pbr = (struct pbr_sector_t *)tmp_bh->b_data;
 
 	/* check the validity of PBR */
 	if (GET16_A(p_pbr->signature) != PBR_SIGNATURE) {
@@ -480,16 +387,22 @@ static int ffsMountVol(struct super_block *sb)
 		goto out;
 	}
 
-	/* fill fs_stuct */
+	/* fill fs_struct */
 	for (i = 0; i < 53; i++)
 		if (p_pbr->bpb[i])
 			break;
 
 	if (i < 53) {
+#ifdef CONFIG_EXFAT_DONT_MOUNT_VFAT
+		ret = -EINVAL;
+		printk(KERN_INFO "EXFAT: Attempted to mount VFAT filesystem\n");
+		goto out;
+#else
 		if (GET16(p_pbr->bpb + 11)) /* num_fat_sectors */
 			ret = fat16_mount(sb, p_pbr);
 		else
 			ret = fat32_mount(sb, p_pbr);
+#endif
 	} else {
 		ret = exfat_mount(sb, p_pbr);
 	}
@@ -581,13 +494,13 @@ static int ffsGetVolInfo(struct super_block *sb, struct vol_info_t *info)
 	struct fs_info_t *p_fs = &(EXFAT_SB(sb)->fs_info);
 
 	/* check the validity of pointer parameters */
-	if (info == NULL)
+	if (!info)
 		return FFS_ERROR;
 
 	/* acquire the lock for file system critical section */
 	down(&p_fs->v_sem);
 
-	if (p_fs->used_clusters == (u32) ~0)
+	if (p_fs->used_clusters == UINT_MAX)
 		p_fs->used_clusters = p_fs->fs_func->count_used_clusters(sb);
 
 	info->FatType = p_fs->vol_type;
@@ -644,7 +557,7 @@ static int ffsLookupFile(struct inode *inode, char *path, struct file_id_t *fid)
 	pr_debug("%s entered\n", __func__);
 
 	/* check the validity of pointer parameters */
-	if ((fid == NULL) || (path == NULL) || (*path == '\0'))
+	if (!fid || !path || (*path == '\0'))
 		return FFS_ERROR;
 
 	/* acquire the lock for file system critical section */
@@ -664,7 +577,7 @@ static int ffsLookupFile(struct inode *inode, char *path, struct file_id_t *fid)
 	dentry = p_fs->fs_func->find_dir_entry(sb, &dir, &uni_name, num_entries,
 					       &dos_name, TYPE_ALL);
 	if (dentry < -1) {
-		return FFS_NOTFOUND;
+		ret = FFS_NOTFOUND;
 		goto out;
 	}
 
@@ -690,7 +603,7 @@ static int ffsLookupFile(struct inode *inode, char *path, struct file_id_t *fid)
 				ret =  FFS_MEDIAERR;
 				goto out;
 			}
-			ep2 = ep+1;
+			ep2 = ep + 1;
 		} else {
 			ep = get_entry_in_dir(sb, &dir, dentry, NULL);
 			if (!ep) {
@@ -737,7 +650,7 @@ static int ffsCreateFile(struct inode *inode, char *path, u8 mode,
 	int ret;
 
 	/* check the validity of pointer parameters */
-	if ((fid == NULL) || (path == NULL) || (*path == '\0'))
+	if (!fid || !path || (*path == '\0'))
 		return FFS_ERROR;
 
 	/* acquire the lock for file system critical section */
@@ -773,7 +686,7 @@ static int ffsReadFile(struct inode *inode, struct file_id_t *fid, void *buffer,
 {
 	s32 offset, sec_offset, clu_offset;
 	u32 clu;
-	int ret;
+	int ret = 0;
 	sector_t LogSector;
 	u64 oneblkread, read_bytes;
 	struct buffer_head *tmp_bh = NULL;
@@ -782,11 +695,11 @@ static int ffsReadFile(struct inode *inode, struct file_id_t *fid, void *buffer,
 	struct bd_info_t *p_bd = &(EXFAT_SB(sb)->bd_info);
 
 	/* check the validity of the given file id */
-	if (fid == NULL)
+	if (!fid)
 		return FFS_INVALIDFID;
 
 	/* check the validity of pointer parameters */
-	if (buffer == NULL)
+	if (!buffer)
 		return FFS_ERROR;
 
 	/* acquire the lock for file system critical section */
@@ -805,7 +718,7 @@ static int ffsReadFile(struct inode *inode, struct file_id_t *fid, void *buffer,
 		count = fid->size - fid->rwoffset;
 
 	if (count == 0) {
-		if (rcount != NULL)
+		if (rcount)
 			*rcount = 0;
 		ret = FFS_EOF;
 		goto out;
@@ -842,7 +755,7 @@ static int ffsReadFile(struct inode *inode, struct file_id_t *fid, void *buffer,
 		fid->hint_last_clu = clu;
 
 		/* byte offset in cluster */
-		offset = (s32)(fid->rwoffset & (p_fs->cluster_size-1));
+		offset = (s32)(fid->rwoffset & (p_fs->cluster_size - 1));
 
 		/* sector offset in cluster */
 		sec_offset = offset >> p_bd->sector_size_bits;
@@ -879,7 +792,7 @@ static int ffsReadFile(struct inode *inode, struct file_id_t *fid, void *buffer,
 /* How did this ever work and not leak a brlse()?? */
 err_out:
 	/* set the size of read bytes */
-	if (rcount != NULL)
+	if (rcount)
 		*rcount = read_bytes;
 
 	if (p_fs->dev_ejected)
@@ -895,8 +808,9 @@ static int ffsReadFile(struct inode *inode, struct file_id_t *fid, void *buffer,
 static int ffsWriteFile(struct inode *inode, struct file_id_t *fid,
 			void *buffer, u64 count, u64 *wcount)
 {
-	s32 modified = FALSE, offset, sec_offset, clu_offset;
-	s32 num_clusters, num_alloc, num_alloced = (s32) ~0;
+	bool modified = false;
+	s32 offset, sec_offset, clu_offset;
+	s32 num_clusters, num_alloc, num_alloced = (s32)~0;
 	int ret = 0;
 	u32 clu, last_clu;
 	sector_t LogSector, sector = 0;
@@ -911,11 +825,11 @@ static int ffsWriteFile(struct inode *inode, struct file_id_t *fid,
 	struct bd_info_t *p_bd = &(EXFAT_SB(sb)->bd_info);
 
 	/* check the validity of the given file id */
-	if (fid == NULL)
+	if (!fid)
 		return FFS_INVALIDFID;
 
 	/* check the validity of pointer parameters */
-	if (buffer == NULL)
+	if (!buffer)
 		return FFS_ERROR;
 
 	/* acquire the lock for file system critical section */
@@ -931,7 +845,7 @@ static int ffsWriteFile(struct inode *inode, struct file_id_t *fid,
 		fid->rwoffset = fid->size;
 
 	if (count == 0) {
-		if (wcount != NULL)
+		if (wcount)
 			*wcount = 0;
 		ret = FFS_SUCCESS;
 		goto out;
@@ -942,7 +856,7 @@ static int ffsWriteFile(struct inode *inode, struct file_id_t *fid,
 	if (fid->size == 0)
 		num_clusters = 0;
 	else
-		num_clusters = (s32)((fid->size-1) >>
+		num_clusters = (s32)((fid->size - 1) >>
 				     p_fs->cluster_size_bits) + 1;
 
 	write_bytes = 0;
@@ -983,7 +897,7 @@ static int ffsWriteFile(struct inode *inode, struct file_id_t *fid,
 			num_alloc = (s32)((count - 1) >>
 					  p_fs->cluster_size_bits) + 1;
 			new_clu.dir = (last_clu == CLUSTER_32(~0)) ?
-					CLUSTER_32(~0) : last_clu+1;
+					CLUSTER_32(~0) : last_clu + 1;
 			new_clu.size = 0;
 			new_clu.flags = fid->flags;
 
@@ -993,7 +907,7 @@ static int ffsWriteFile(struct inode *inode, struct file_id_t *fid,
 								   &new_clu);
 			if (num_alloced == 0)
 				break;
-			else if (num_alloced < 0) {
+			if (num_alloced < 0) {
 				ret = FFS_MEDIAERR;
 				goto out;
 			}
@@ -1003,14 +917,14 @@ static int ffsWriteFile(struct inode *inode, struct file_id_t *fid,
 				if (new_clu.flags == 0x01)
 					fid->flags = 0x01;
 				fid->start_clu = new_clu.dir;
-				modified = TRUE;
+				modified = true;
 			} else {
 				if (new_clu.flags != fid->flags) {
 					exfat_chain_cont_cluster(sb,
 								 fid->start_clu,
 								 num_clusters);
 					fid->flags = 0x01;
-					modified = TRUE;
+					modified = true;
 				}
 				if (new_clu.flags == 0x01)
 					FAT_write(sb, last_clu, new_clu.dir);
@@ -1053,7 +967,7 @@ static int ffsWriteFile(struct inode *inode, struct file_id_t *fid,
 			}
 		} else {
 			if ((offset > 0) ||
-			    ((fid->rwoffset+oneblkwrite) < fid->size)) {
+			    ((fid->rwoffset + oneblkwrite) < fid->size)) {
 				if (sector_read(sb, LogSector, &tmp_bh, 1) !=
 				    FFS_SUCCESS)
 					goto err_out;
@@ -1080,7 +994,7 @@ static int ffsWriteFile(struct inode *inode, struct file_id_t *fid,
 
 		if (fid->size < fid->rwoffset) {
 			fid->size = fid->rwoffset;
-			modified = TRUE;
+			modified = true;
 		}
 	}
 
@@ -1090,9 +1004,9 @@ static int ffsWriteFile(struct inode *inode, struct file_id_t *fid,
 	if (p_fs->vol_type == EXFAT) {
 		es = get_entry_set_in_dir(sb, &(fid->dir), fid->entry,
 					  ES_ALL_ENTRIES, &ep);
-		if (es == NULL)
+		if (!es)
 			goto err_out;
-		ep2 = ep+1;
+		ep2 = ep + 1;
 	} else {
 		ep = get_entry_in_dir(sb, &(fid->dir), fid->entry, &sector);
 		if (!ep)
@@ -1132,7 +1046,7 @@ static int ffsWriteFile(struct inode *inode, struct file_id_t *fid,
 
 err_out:
 	/* set the size of written bytes */
-	if (wcount != NULL)
+	if (wcount)
 		*wcount = write_bytes;
 
 	if (num_alloced == 0)
@@ -1187,11 +1101,11 @@ static int ffsTruncateFile(struct inode *inode, u64 old_size, u64 new_size)
 	fs_set_vol_flags(sb, VOL_DIRTY);
 
 	clu.dir = fid->start_clu;
-	clu.size = (s32)((old_size-1) >> p_fs->cluster_size_bits) + 1;
+	clu.size = (s32)((old_size - 1) >> p_fs->cluster_size_bits) + 1;
 	clu.flags = fid->flags;
 
 	if (new_size > 0) {
-		num_clusters = (s32)((new_size-1) >>
+		num_clusters = (s32)((new_size - 1) >>
 				     p_fs->cluster_size_bits) + 1;
 
 		if (clu.flags == 0x03) {
@@ -1199,8 +1113,10 @@ static int ffsTruncateFile(struct inode *inode, u64 old_size, u64 new_size)
 		} else {
 			while (num_clusters > 0) {
 				last_clu = clu.dir;
-				if (FAT_read(sb, clu.dir, &clu.dir) == -1)
-					return FFS_MEDIAERR;
+				if (FAT_read(sb, clu.dir, &clu.dir) == -1) {
+					ret = FFS_MEDIAERR;
+					goto out;
+				}
 				num_clusters--;
 			}
 		}
@@ -1219,11 +1135,11 @@ static int ffsTruncateFile(struct inode *inode, u64 old_size, u64 new_size)
 	if (p_fs->vol_type == EXFAT) {
 		es = get_entry_set_in_dir(sb, &fid->dir, fid->entry,
 					  ES_ALL_ENTRIES, &ep);
-		if (es == NULL) {
+		if (!es) {
 			ret = FFS_MEDIAERR;
 			goto out;
 			}
-		ep2 = ep+1;
+		ep2 = ep + 1;
 	} else {
 		ep = get_entry_in_dir(sb, &(fid->dir), fid->entry, &sector);
 		if (!ep) {
@@ -1242,9 +1158,9 @@ static int ffsTruncateFile(struct inode *inode, u64 old_size, u64 new_size)
 		p_fs->fs_func->set_entry_clu0(ep2, CLUSTER_32(0));
 	}
 
-	if (p_fs->vol_type != EXFAT)
+	if (p_fs->vol_type != EXFAT) {
 		buf_modify(sb, sector);
-	else {
+	} else {
 		update_dir_checksum_with_entry_set(sb, es);
 		release_entry_set(es);
 	}
@@ -1291,7 +1207,7 @@ static void update_parent_info(struct file_id_t *fid,
 		     (parent_fid->start_clu != fid->dir.dir))) {
 		fid->dir.dir = parent_fid->start_clu;
 		fid->dir.flags = parent_fid->flags;
-		fid->dir.size = ((parent_fid->size + (p_fs->cluster_size-1))
+		fid->dir.size = ((parent_fid->size + (p_fs->cluster_size - 1))
 						>> p_fs->cluster_size_bits);
 	}
 }
@@ -1307,18 +1223,18 @@ static int ffsMoveFile(struct inode *old_parent_inode, struct file_id_t *fid,
 	struct dentry_t *ep;
 	struct super_block *sb = old_parent_inode->i_sb;
 	struct fs_info_t *p_fs = &(EXFAT_SB(sb)->fs_info);
-	u8 *new_path = (u8 *) new_dentry->d_name.name;
+	u8 *new_path = (u8 *)new_dentry->d_name.name;
 	struct inode *new_inode = new_dentry->d_inode;
 	int num_entries;
 	struct file_id_t *new_fid = NULL;
 	s32 new_entry = 0;
 
 	/* check the validity of the given file id */
-	if (fid == NULL)
+	if (!fid)
 		return FFS_INVALIDFID;
 
 	/* check the validity of pointer parameters */
-	if ((new_path == NULL) || (*new_path == '\0'))
+	if (!new_path || (*new_path == '\0'))
 		return FFS_ERROR;
 
 	/* acquire the lock for file system critical section */
@@ -1408,7 +1324,7 @@ static int ffsMoveFile(struct inode *old_parent_inode, struct file_id_t *fid,
 		if (num_entries < 0)
 			goto out;
 		p_fs->fs_func->delete_dir_entry(sb, p_dir, new_entry, 0,
-						num_entries+1);
+						num_entries + 1);
 	}
 out:
 #ifdef CONFIG_EXFAT_DELAYED_SYNC
@@ -1435,7 +1351,7 @@ static int ffsRemoveFile(struct inode *inode, struct file_id_t *fid)
 	struct fs_info_t *p_fs = &(EXFAT_SB(sb)->fs_info);
 
 	/* check the validity of the given file id */
-	if (fid == NULL)
+	if (!fid)
 		return FFS_INVALIDFID;
 
 	/* acquire the lock for file system critical section */
@@ -1463,7 +1379,7 @@ static int ffsRemoveFile(struct inode *inode, struct file_id_t *fid)
 	remove_file(inode, &dir, dentry);
 
 	clu_to_free.dir = fid->start_clu;
-	clu_to_free.size = (s32)((fid->size-1) >> p_fs->cluster_size_bits) + 1;
+	clu_to_free.size = (s32)((fid->size - 1) >> p_fs->cluster_size_bits) + 1;
 	clu_to_free.flags = fid->flags;
 
 	/* (2) free the clusters */
@@ -1523,7 +1439,7 @@ static int ffsSetAttr(struct inode *inode, u32 attr)
 	if (p_fs->vol_type == EXFAT) {
 		es = get_entry_set_in_dir(sb, &(fid->dir), fid->entry,
 					  ES_ALL_ENTRIES, &ep);
-		if (es == NULL) {
+		if (!es) {
 			ret = FFS_MEDIAERR;
 			goto out;
 		}
@@ -1555,9 +1471,9 @@ static int ffsSetAttr(struct inode *inode, u32 attr)
 	fid->attr = attr;
 	p_fs->fs_func->set_entry_attr(ep, attr);
 
-	if (p_fs->vol_type != EXFAT)
+	if (p_fs->vol_type != EXFAT) {
 		buf_modify(sb, sector);
-	else {
+	} else {
 		update_dir_checksum_with_entry_set(sb, es);
 		release_entry_set(es);
 	}
@@ -1639,11 +1555,11 @@ static int ffsReadStat(struct inode *inode, struct dir_entry_t *info)
 	if (p_fs->vol_type == EXFAT) {
 		es = get_entry_set_in_dir(sb, &(fid->dir), fid->entry,
 					  ES_2_ENTRIES, &ep);
-		if (es == NULL) {
+		if (!es) {
 			ret = FFS_MEDIAERR;
 			goto out;
 		}
-		ep2 = ep+1;
+		ep2 = ep + 1;
 	} else {
 		ep = get_entry_in_dir(sb, &(fid->dir), fid->entry, &sector);
 		if (!ep) {
@@ -1675,7 +1591,7 @@ static int ffsReadStat(struct inode *inode, struct dir_entry_t *info)
 	info->ModifyTimestamp.Second = tm.sec;
 	info->ModifyTimestamp.MilliSecond = 0;
 
-	memset((char *) &info->AccessTimestamp, 0, sizeof(struct date_time_t));
+	memset((char *)&info->AccessTimestamp, 0, sizeof(struct date_time_t));
 
 	*(uni_name.name) = 0x0;
 	/* XXX this is very bad for exfat cuz name is already included in es.
@@ -1763,11 +1679,11 @@ static int ffsWriteStat(struct inode *inode, struct dir_entry_t *info)
 	if (p_fs->vol_type == EXFAT) {
 		es = get_entry_set_in_dir(sb, &(fid->dir), fid->entry,
 					  ES_ALL_ENTRIES, &ep);
-		if (es == NULL) {
+		if (!es) {
 			ret = FFS_MEDIAERR;
 			goto out;
 		}
-		ep2 = ep+1;
+		ep2 = ep + 1;
 	} else {
 		/* for other than exfat */
 		ep = get_entry_in_dir(sb, &(fid->dir), fid->entry, &sector);
@@ -1820,7 +1736,8 @@ static int ffsWriteStat(struct inode *inode, struct dir_entry_t *info)
 
 static int ffsMapCluster(struct inode *inode, s32 clu_offset, u32 *clu)
 {
-	s32 num_clusters, num_alloced, modified = FALSE;
+	s32 num_clusters, num_alloced;
+	bool modified = false;
 	u32 last_clu;
 	int ret = FFS_SUCCESS;
 	sector_t sector = 0;
@@ -1832,7 +1749,7 @@ static int ffsMapCluster(struct inode *inode, s32 clu_offset, u32 *clu)
 	struct file_id_t *fid = &(EXFAT_I(inode)->fid);
 
 	/* check the validity of pointer parameters */
-	if (clu == NULL)
+	if (!clu)
 		return FFS_ERROR;
 
 	/* acquire the lock for file system critical section */
@@ -1898,13 +1815,13 @@ static int ffsMapCluster(struct inode *inode, s32 clu_offset, u32 *clu)
 			if (new_clu.flags == 0x01)
 				fid->flags = 0x01;
 			fid->start_clu = new_clu.dir;
-			modified = TRUE;
+			modified = true;
 		} else {
 			if (new_clu.flags != fid->flags) {
 				exfat_chain_cont_cluster(sb, fid->start_clu,
 							 num_clusters);
 				fid->flags = 0x01;
-				modified = TRUE;
+				modified = true;
 			}
 			if (new_clu.flags == 0x01)
 				FAT_write(sb, last_clu, new_clu.dir);
@@ -1916,7 +1833,7 @@ static int ffsMapCluster(struct inode *inode, s32 clu_offset, u32 *clu)
 		if (p_fs->vol_type == EXFAT) {
 			es = get_entry_set_in_dir(sb, &fid->dir, fid->entry,
 						  ES_ALL_ENTRIES, &ep);
-			if (es == NULL) {
+			if (!es) {
 				ret = FFS_MEDIAERR;
 				goto out;
 			}
@@ -1984,7 +1901,7 @@ static int ffsCreateDir(struct inode *inode, char *path, struct file_id_t *fid)
 	pr_debug("%s entered\n", __func__);
 
 	/* check the validity of pointer parameters */
-	if ((fid == NULL) || (path == NULL) || (*path == '\0'))
+	if (!fid || !path || (*path == '\0'))
 		return FFS_ERROR;
 
 	/* acquire the lock for file system critical section */
@@ -2030,7 +1947,7 @@ static int ffsReadDir(struct inode *inode, struct dir_entry_t *dir_entry)
 	struct file_id_t *fid = &(EXFAT_I(inode)->fid);
 
 	/* check the validity of pointer parameters */
-	if (dir_entry == NULL)
+	if (!dir_entry)
 		return FFS_ERROR;
 
 	/* check if the given file ID is opened */
@@ -2100,7 +2017,7 @@ static int ffsReadDir(struct inode *inode, struct dir_entry_t *dir_entry)
 		if (dir.dir == CLUSTER_32(0)) /* FAT16 root_dir */
 			i = dentry % dentries_per_clu;
 		else
-			i = dentry & (dentries_per_clu-1);
+			i = dentry & (dentries_per_clu - 1);
 
 		for ( ; i < dentries_per_clu; i++, dentry++) {
 			ep = get_entry_in_dir(sb, &clu, i, &sector);
@@ -2151,7 +2068,7 @@ static int ffsReadDir(struct inode *inode, struct dir_entry_t *dir_entry)
 			buf_unlock(sb, sector);
 
 			if (p_fs->vol_type == EXFAT) {
-				ep = get_entry_in_dir(sb, &clu, i+1, NULL);
+				ep = get_entry_in_dir(sb, &clu, i + 1, NULL);
 				if (!ep) {
 					ret = FFS_MEDIAERR;
 					goto out;
@@ -2174,7 +2091,7 @@ static int ffsReadDir(struct inode *inode, struct dir_entry_t *dir_entry)
 				fid->hint_last_clu = clu.dir;
 			}
 
-			fid->rwoffset = (s64) ++dentry;
+			fid->rwoffset = (s64)(++dentry);
 
 			if (p_fs->dev_ejected)
 				ret = FFS_MEDIAERR;
@@ -2200,7 +2117,7 @@ static int ffsReadDir(struct inode *inode, struct dir_entry_t *dir_entry)
 
 	*(dir_entry->Name) = '\0';
 
-	fid->rwoffset = (s64) ++dentry;
+	fid->rwoffset = (s64)(++dentry);
 
 	if (p_fs->dev_ejected)
 		ret = FFS_MEDIAERR;
@@ -2221,7 +2138,7 @@ static int ffsRemoveDir(struct inode *inode, struct file_id_t *fid)
 	struct fs_info_t *p_fs = &(EXFAT_SB(sb)->fs_info);
 
 	/* check the validity of the given file id */
-	if (fid == NULL)
+	if (!fid)
 		return FFS_INVALIDFID;
 
 	dir.dir = fid->dir.dir;
@@ -2240,7 +2157,7 @@ static int ffsRemoveDir(struct inode *inode, struct file_id_t *fid)
 	down(&p_fs->v_sem);
 
 	clu_to_free.dir = fid->start_clu;
-	clu_to_free.size = (s32)((fid->size-1) >> p_fs->cluster_size_bits) + 1;
+	clu_to_free.size = (s32)((fid->size - 1) >> p_fs->cluster_size_bits) + 1;
 	clu_to_free.flags = fid->flags;
 
 	if (!is_dir_empty(sb, &clu_to_free)) {
@@ -2328,7 +2245,7 @@ static int exfat_readdir(struct file *filp, struct dir_context *ctx)
 		 */
 		if (err == FFS_MEDIAERR) {
 			cpos += 1 << p_bd->sector_size_bits;
-			cpos &= ~((1 << p_bd->sector_size_bits)-1);
+			cpos &= ~((1 << p_bd->sector_size_bits) - 1);
 		}
 
 		err = -EIO;
@@ -2345,8 +2262,8 @@ static int exfat_readdir(struct file *filp, struct dir_context *ctx)
 	} else if (!memcmp(de.ShortName, DOS_PAR_DIR_NAME, DOS_NAME_LENGTH)) {
 		inum = parent_ino(filp->f_path.dentry);
 	} else {
-		loff_t i_pos = ((loff_t) EXFAT_I(inode)->fid.start_clu << 32) |
-				((EXFAT_I(inode)->fid.rwoffset-1) & 0xffffffff);
+		loff_t i_pos = ((loff_t)EXFAT_I(inode)->fid.start_clu << 32) |
+				((EXFAT_I(inode)->fid.rwoffset - 1) & 0xffffffff);
 		struct inode *tmp = exfat_iget(sb, i_pos);
 
 		if (tmp) {
@@ -2406,7 +2323,7 @@ struct inode *inode = filp->f_path.dentry->d_inode;
 		if (!capable(CAP_SYS_ADMIN))
 			return -EPERM;
 
-		if (get_user(flags, (int __user *) arg))
+		if (get_user(flags, (int __user *)arg))
 			return -EFAULT;
 
 		__lock_super(sb);
@@ -2442,7 +2359,7 @@ static int exfat_create(struct inode *dir, struct dentry *dentry, umode_t mode,
 
 	pr_debug("%s entered\n", __func__);
 
-	err = ffsCreateFile(dir, (u8 *) dentry->d_name.name, FM_REGULAR, &fid);
+	err = ffsCreateFile(dir, (u8 *)dentry->d_name.name, FM_REGULAR, &fid);
 	if (err) {
 		if (err == FFS_INVALIDPATH)
 			err = -EINVAL;
@@ -2459,11 +2376,11 @@ static int exfat_create(struct inode *dir, struct dentry *dentry, umode_t mode,
 	INC_IVERSION(dir);
 	dir->i_ctime = dir->i_mtime = dir->i_atime = current_time(dir);
 	if (IS_DIRSYNC(dir))
-		(void) exfat_sync_inode(dir);
+		(void)exfat_sync_inode(dir);
 	else
 		mark_inode_dirty(dir);
 
-	i_pos = ((loff_t) fid.dir.dir << 32) | (fid.entry & 0xffffffff);
+	i_pos = ((loff_t)fid.dir.dir << 32) | (fid.entry & 0xffffffff);
 
 	inode = exfat_build_inode(sb, &fid, i_pos);
 	if (IS_ERR(inode)) {
@@ -2493,7 +2410,7 @@ static int exfat_find(struct inode *dir, struct qstr *qname,
 	if (qname->len == 0)
 		return -ENOENT;
 
-	err = ffsLookupFile(dir, (u8 *) qname->name, fid);
+	err = ffsLookupFile(dir, (u8 *)qname->name, fid);
 	if (err)
 		return -ENOENT;
 
@@ -2528,7 +2445,7 @@ static struct dentry *exfat_lookup(struct inode *dir, struct dentry *dentry,
 		goto error;
 	}
 
-	i_pos = ((loff_t) fid.dir.dir << 32) | (fid.entry & 0xffffffff);
+	i_pos = ((loff_t)fid.dir.dir << 32) | (fid.entry & 0xffffffff);
 	inode = exfat_build_inode(sb, &fid, i_pos);
 	if (IS_ERR(inode)) {
 		err = PTR_ERR(inode);
@@ -2623,7 +2540,7 @@ static int exfat_unlink(struct inode *dir, struct dentry *dentry)
 	INC_IVERSION(dir);
 	dir->i_mtime = dir->i_atime = current_time(dir);
 	if (IS_DIRSYNC(dir))
-		(void) exfat_sync_inode(dir);
+		(void)exfat_sync_inode(dir);
 	else
 		mark_inode_dirty(dir);
 
@@ -2646,14 +2563,14 @@ static int exfat_symlink(struct inode *dir, struct dentry *dentry,
 	struct file_id_t fid;
 	loff_t i_pos;
 	int err;
-	u64 len = (u64) strlen(target);
+	u64 len = (u64)strlen(target);
 	u64 ret;
 
 	__lock_super(sb);
 
 	pr_debug("%s entered\n", __func__);
 
-	err = ffsCreateFile(dir, (u8 *) dentry->d_name.name, FM_SYMLINK, &fid);
+	err = ffsCreateFile(dir, (u8 *)dentry->d_name.name, FM_SYMLINK, &fid);
 	if (err) {
 		if (err == FFS_INVALIDPATH)
 			err = -EINVAL;
@@ -2666,7 +2583,7 @@ static int exfat_symlink(struct inode *dir, struct dentry *dentry,
 		goto out;
 	}
 
-	err = ffsWriteFile(dir, &fid, (char *) target, len, &ret);
+	err = ffsWriteFile(dir, &fid, (char *)target, len, &ret);
 
 	if (err) {
 		ffsRemoveFile(dir, &fid);
@@ -2681,11 +2598,11 @@ static int exfat_symlink(struct inode *dir, struct dentry *dentry,
 	INC_IVERSION(dir);
 	dir->i_ctime = dir->i_mtime = dir->i_atime = current_time(dir);
 	if (IS_DIRSYNC(dir))
-		(void) exfat_sync_inode(dir);
+		(void)exfat_sync_inode(dir);
 	else
 		mark_inode_dirty(dir);
 
-	i_pos = ((loff_t) fid.dir.dir << 32) | (fid.entry & 0xffffffff);
+	i_pos = ((loff_t)fid.dir.dir << 32) | (fid.entry & 0xffffffff);
 
 	inode = exfat_build_inode(sb, &fid, i_pos);
 	if (IS_ERR(inode)) {
@@ -2696,12 +2613,11 @@ static int exfat_symlink(struct inode *dir, struct dentry *dentry,
 	inode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);
 	/* timestamp is already written, so mark_inode_dirty() is unneeded. */
 
-	EXFAT_I(inode)->target = kmalloc(len+1, GFP_KERNEL);
+	EXFAT_I(inode)->target = kmemdup(target, len + 1, GFP_KERNEL);
 	if (!EXFAT_I(inode)->target) {
 		err = -ENOMEM;
 		goto out;
 	}
-	memcpy(EXFAT_I(inode)->target, target, len+1);
 
 	dentry->d_time = GET_IVERSION(dentry->d_parent->d_inode);
 	d_instantiate(dentry, inode);
@@ -2724,7 +2640,7 @@ static int exfat_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
 
 	pr_debug("%s entered\n", __func__);
 
-	err = ffsCreateDir(dir, (u8 *) dentry->d_name.name, &fid);
+	err = ffsCreateDir(dir, (u8 *)dentry->d_name.name, &fid);
 	if (err) {
 		if (err == FFS_INVALIDPATH)
 			err = -EINVAL;
@@ -2741,12 +2657,12 @@ static int exfat_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
 	INC_IVERSION(dir);
 	dir->i_ctime = dir->i_mtime = dir->i_atime = current_time(dir);
 	if (IS_DIRSYNC(dir))
-		(void) exfat_sync_inode(dir);
+		(void)exfat_sync_inode(dir);
 	else
 		mark_inode_dirty(dir);
 	inc_nlink(dir);
 
-	i_pos = ((loff_t) fid.dir.dir << 32) | (fid.entry & 0xffffffff);
+	i_pos = ((loff_t)fid.dir.dir << 32) | (fid.entry & 0xffffffff);
 
 	inode = exfat_build_inode(sb, &fid, i_pos);
 	if (IS_ERR(inode)) {
@@ -2795,7 +2711,7 @@ static int exfat_rmdir(struct inode *dir, struct dentry *dentry)
 	INC_IVERSION(dir);
 	dir->i_mtime = dir->i_atime = current_time(dir);
 	if (IS_DIRSYNC(dir))
-		(void) exfat_sync_inode(dir);
+		(void)exfat_sync_inode(dir);
 	else
 		mark_inode_dirty(dir);
 	drop_nlink(dir);
@@ -2853,17 +2769,17 @@ static int exfat_rename(struct inode *old_dir, struct dentry *old_dentry,
 	new_dir->i_ctime = new_dir->i_mtime = new_dir->i_atime =
 				current_time(new_dir);
 	if (IS_DIRSYNC(new_dir))
-		(void) exfat_sync_inode(new_dir);
+		(void)exfat_sync_inode(new_dir);
 	else
 		mark_inode_dirty(new_dir);
 
-	i_pos = ((loff_t) EXFAT_I(old_inode)->fid.dir.dir << 32) |
+	i_pos = ((loff_t)EXFAT_I(old_inode)->fid.dir.dir << 32) |
 			(EXFAT_I(old_inode)->fid.entry & 0xffffffff);
 
 	exfat_detach(old_inode);
 	exfat_attach(old_inode, i_pos);
 	if (IS_DIRSYNC(new_dir))
-		(void) exfat_sync_inode(old_inode);
+		(void)exfat_sync_inode(old_inode);
 	else
 		mark_inode_dirty(old_inode);
 
@@ -2875,7 +2791,7 @@ static int exfat_rename(struct inode *old_dir, struct dentry *old_dentry,
 	INC_IVERSION(old_dir);
 	old_dir->i_ctime = old_dir->i_mtime = current_time(old_dir);
 	if (IS_DIRSYNC(old_dir))
-		(void) exfat_sync_inode(old_dir);
+		(void)exfat_sync_inode(old_dir);
 	else
 		mark_inode_dirty(old_dir);
 
@@ -2999,7 +2915,7 @@ static void exfat_truncate(struct inode *inode, loff_t old_size)
 
 	inode->i_ctime = inode->i_mtime = current_time(inode);
 	if (IS_DIRSYNC(inode))
-		(void) exfat_sync_inode(inode);
+		(void)exfat_sync_inode(inode);
 	else
 		mark_inode_dirty(inode);
 
@@ -3011,7 +2927,6 @@ static void exfat_truncate(struct inode *inode, loff_t old_size)
 
 static int exfat_setattr(struct dentry *dentry, struct iattr *attr)
 {
-
 	struct exfat_sb_info *sbi = EXFAT_SB(dentry->d_sb);
 	struct inode *inode = dentry->d_inode;
 	unsigned int ia_valid;
@@ -3110,10 +3025,10 @@ static const char *exfat_get_link(struct dentry *dentry, struct inode *inode,
 {
 	struct exfat_inode_info *ei = EXFAT_I(inode);
 
-	if (ei->target != NULL) {
+	if (ei->target) {
 		char *cookie = ei->target;
 
-		if (cookie != NULL)
+		if (cookie)
 			return (char *)(ei->target);
 	}
 	return NULL;
@@ -3172,7 +3087,7 @@ static int exfat_bmap(struct inode *inode, sector_t sector, sector_t *phys,
 		if (inode->i_ino == EXFAT_ROOT_INO) {
 			if (sector <
 			    (p_fs->dentries_in_root >>
-			     (p_bd->sector_size_bits-DENTRY_SIZE_BITS))) {
+			     (p_bd->sector_size_bits - DENTRY_SIZE_BITS))) {
 				*phys = sector + p_fs->root_start_sector;
 				*mapped_blocks = 1;
 			}
@@ -3289,7 +3204,7 @@ static int exfat_write_begin(struct file *file, struct address_space *mapping,
 			       &EXFAT_I(mapping->host)->mmu_private);
 
 	if (ret < 0)
-		exfat_write_failed(mapping, pos+len);
+		exfat_write_failed(mapping, pos + len);
 	return ret;
 }
 
@@ -3304,7 +3219,7 @@ static int exfat_write_end(struct file *file, struct address_space *mapping,
 	err = generic_write_end(file, mapping, pos, len, copied, pagep, fsdata);
 
 	if (err < len)
-		exfat_write_failed(mapping, pos+len);
+		exfat_write_failed(mapping, pos + len);
 
 	if (!(err < 0) && !(fid->attr & ATTR_ARCHIVE)) {
 		inode->i_mtime = inode->i_ctime = current_time(inode);
@@ -3432,9 +3347,9 @@ static int exfat_fill_inode(struct inode *inode, struct file_id_t *fid)
 	inode->i_blocks = ((i_size_read(inode) + (p_fs->cluster_size - 1))
 				& ~((loff_t)p_fs->cluster_size - 1)) >> 9;
 
-	exfat_time_fat2unix(sbi, &inode->i_mtime, &info.ModifyTimestamp);
-	exfat_time_fat2unix(sbi, &inode->i_ctime, &info.CreateTimestamp);
-	exfat_time_fat2unix(sbi, &inode->i_atime, &info.AccessTimestamp);
+	exfat_time_fat2unix(&inode->i_mtime, &info.ModifyTimestamp);
+	exfat_time_fat2unix(&inode->i_ctime, &info.CreateTimestamp);
+	exfat_time_fat2unix(&inode->i_atime, &info.AccessTimestamp);
 
 	return 0;
 }
@@ -3487,8 +3402,7 @@ static struct inode *exfat_alloc_inode(struct super_block *sb)
 
 static void exfat_destroy_inode(struct inode *inode)
 {
-	if (EXFAT_I(inode)->target)
-		kfree(EXFAT_I(inode)->target);
+	kfree(EXFAT_I(inode)->target);
 	EXFAT_I(inode)->target = NULL;
 
 	kmem_cache_free(exfat_inode_cachep, EXFAT_I(inode));
@@ -3496,8 +3410,6 @@ static void exfat_destroy_inode(struct inode *inode)
 
 static int exfat_write_inode(struct inode *inode, struct writeback_control *wbc)
 {
-	struct super_block *sb = inode->i_sb;
-	struct exfat_sb_info *sbi = EXFAT_SB(sb);
 	struct dir_entry_t info;
 
 	if (inode->i_ino == EXFAT_ROOT_INO)
@@ -3506,9 +3418,9 @@ static int exfat_write_inode(struct inode *inode, struct writeback_control *wbc)
 	info.Attr = exfat_make_attr(inode);
 	info.Size = i_size_read(inode);
 
-	exfat_time_unix2fat(sbi, &inode->i_mtime, &info.ModifyTimestamp);
-	exfat_time_unix2fat(sbi, &inode->i_ctime, &info.CreateTimestamp);
-	exfat_time_unix2fat(sbi, &inode->i_atime, &info.AccessTimestamp);
+	exfat_time_unix2fat(&inode->i_mtime, &info.ModifyTimestamp);
+	exfat_time_unix2fat(&inode->i_ctime, &info.CreateTimestamp);
+	exfat_time_unix2fat(&inode->i_atime, &info.AccessTimestamp);
 
 	ffsWriteStat(inode, &info);
 
@@ -3587,7 +3499,7 @@ static int exfat_statfs(struct dentry *dentry, struct kstatfs *buf)
 	struct fs_info_t *p_fs = &(EXFAT_SB(sb)->fs_info);
 	struct vol_info_t info;
 
-	if (p_fs->used_clusters == (u32) ~0) {
+	if (p_fs->used_clusters == UINT_MAX) {
 		if (ffsGetVolInfo(sb, &info) == FFS_MEDIAERR)
 			return -EIO;
 
@@ -3762,7 +3674,7 @@ static int parse_options(char *options, int silent, int *debug,
 	opts->fs_uid = current_uid();
 	opts->fs_gid = current_gid();
 	opts->fs_fmask = opts->fs_dmask = current->fs->umask;
-	opts->allow_utime = (unsigned short) -1;
+	opts->allow_utime = U16_MAX;
 	opts->codepage = exfat_default_codepage;
 	opts->iocharset = exfat_default_iocharset;
 	opts->casesensitive = 0;
@@ -3775,7 +3687,7 @@ static int parse_options(char *options, int silent, int *debug,
 	if (!options)
 		goto out;
 
-	while ((p = strsep(&options, ",")) != NULL) {
+	while ((p = strsep(&options, ","))) {
 		int token;
 
 		if (!*p)
@@ -3854,7 +3766,7 @@ static int parse_options(char *options, int silent, int *debug,
 	}
 
 out:
-	if (opts->allow_utime == (unsigned short) -1)
+	if (opts->allow_utime == U16_MAX)
 		opts->allow_utime = ~opts->fs_dmask & 0022;
 
 	return 0;
@@ -3901,7 +3813,7 @@ static int exfat_read_root(struct inode *inode)
 	i_size_write(inode, info.Size);
 	inode->i_blocks = ((i_size_read(inode) + (p_fs->cluster_size - 1))
 				& ~((loff_t)p_fs->cluster_size - 1)) >> 9;
-	EXFAT_I(inode)->i_pos = ((loff_t) p_fs->root_dir << 32) | 0xffffffff;
+	EXFAT_I(inode)->i_pos = ((loff_t)p_fs->root_dir << 32) | 0xffffffff;
 	EXFAT_I(inode)->mmu_private = i_size_read(inode);
 
 	exfat_save_attr(inode, ATTR_SUBDIR);
@@ -4039,7 +3951,7 @@ static int __init exfat_init_inodecache(void)
 					       (SLAB_RECLAIM_ACCOUNT |
 						SLAB_MEM_SPREAD),
 					       init_once);
-	if (exfat_inode_cachep == NULL)
+	if (!exfat_inode_cachep)
 		return -ENOMEM;
 	return 0;
 }
-- 
2.23.0

