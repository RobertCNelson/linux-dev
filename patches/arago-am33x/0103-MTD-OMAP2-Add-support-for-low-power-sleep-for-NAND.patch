From 245b36212eab2832d6b0a4b241d9a51dbae963d3 Mon Sep 17 00:00:00 2001
From: "Philip, Avinash" <avinashphilip@ti.com>
Date: Thu, 16 Feb 2012 12:35:41 +0530
Subject: [PATCH 103/186] MTD: OMAP2: Add support for low power sleep for NAND

Support for NAND low power done by
1. Waiting for ongoing MTD operation to finish before entering low power
mode.
2. Invokes GPMC callbacks to handle GPMC low power transitions.
3. ELM suspend activity waiting for ongoing MTD transfer to finish and
handle ELM low power transition cycle by configuring.

Signed-off-by: Philip, Avinash <avinashphilip@ti.com>
---
 drivers/mtd/devices/omap2_elm.c |   21 +++++++++++++++++++++
 drivers/mtd/nand/omap2.c        |   39 +++++++++++++++++++++++++++++++++++++++
 2 files changed, 60 insertions(+), 0 deletions(-)

diff --git a/drivers/mtd/devices/omap2_elm.c b/drivers/mtd/devices/omap2_elm.c
index d51622d..d156e27 100644
--- a/drivers/mtd/devices/omap2_elm.c
+++ b/drivers/mtd/devices/omap2_elm.c
@@ -332,9 +332,30 @@ static int omap_elm_remove(struct platform_device *pdev)
 }
 
 
+#ifdef CONFIG_PM
+static int omap_elm_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	mtd->suspend(mtd);
+	pm_runtime_put_sync(&pdev->dev);
+	return 0;
+}
+
+static int omap_elm_resume(struct platform_device *pdev)
+{
+	pm_runtime_get_sync(&pdev->dev);
+	/* Restore ELM context by configuring */
+	omap_elm_config(bch_scheme);
+	return 0;
+}
+#endif
+
 static struct platform_driver omap_elm_driver = {
 	.probe		= omap_elm_probe,
 	.remove		= omap_elm_remove,
+#ifdef CONFIG_PM
+	.suspend	= omap_elm_suspend,
+	.resume		= omap_elm_resume,
+#endif
 	.driver		= {
 		.name	= DRIVER_NAME,
 		.owner	= THIS_MODULE,
diff --git a/drivers/mtd/nand/omap2.c b/drivers/mtd/nand/omap2.c
index d4d1335..a2d3e29 100644
--- a/drivers/mtd/nand/omap2.c
+++ b/drivers/mtd/nand/omap2.c
@@ -136,6 +136,8 @@ struct omap_nand_info {
 	u_char				*buf;
 	int				buf_len;
 	int				ecc_opt;
+	int (*ctrlr_suspend) (void);
+	int (*ctrlr_resume) (void);
 };
 
 /**
@@ -1097,6 +1099,11 @@ static int __devinit omap_nand_probe(struct platform_device *pdev)
 			omap_configure_elm(&info->mtd, OMAP_BCH8_ECC);
 	}
 
+	if (pdata->ctrlr_suspend)
+		info->ctrlr_suspend = pdata->ctrlr_suspend;
+	if (pdata->ctrlr_resume)
+		info->ctrlr_resume = pdata->ctrlr_resume;
+
 	/* NAND write protect off */
 	gpmc_cs_configure(info->gpmc_cs, GPMC_CONFIG_WP, 0);
 
@@ -1309,9 +1316,41 @@ static int omap_nand_remove(struct platform_device *pdev)
 	return 0;
 }
 
+#ifdef CONFIG_PM
+static int omap_nand_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct mtd_info *mtd = platform_get_drvdata(pdev);
+	struct omap_nand_info *info = container_of(mtd, struct omap_nand_info,
+							mtd);
+
+	mtd->suspend(mtd);
+
+	if (info->ctrlr_suspend)
+		info->ctrlr_suspend();
+
+	return 0;
+}
+
+static int omap_nand_resume(struct platform_device *pdev)
+{
+	struct mtd_info *mtd = platform_get_drvdata(pdev);
+	struct omap_nand_info *info = container_of(mtd, struct omap_nand_info,
+							mtd);
+
+	if (info->ctrlr_resume)
+		info->ctrlr_resume();
+
+	return 0;
+}
+#endif
+
 static struct platform_driver omap_nand_driver = {
 	.probe		= omap_nand_probe,
 	.remove		= omap_nand_remove,
+#ifdef CONFIG_PM
+	.suspend	= omap_nand_suspend,
+	.resume		= omap_nand_resume,
+#endif
 	.driver		= {
 		.name	= DRIVER_NAME,
 		.owner	= THIS_MODULE,
-- 
1.7.9.1

