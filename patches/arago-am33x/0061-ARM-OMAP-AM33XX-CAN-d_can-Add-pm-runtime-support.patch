From 58a26902404b9500928aab628c8f9bb9453c0bbe Mon Sep 17 00:00:00 2001
From: AnilKumar Ch <anilkumar@ti.com>
Date: Tue, 6 Mar 2012 19:21:08 +0530
Subject: [PATCH 061/193] ARM: OMAP: AM33XX: CAN: d_can: Add pm runtime
 support

This patch adds the pm_runtime support to DCAN driver by
replacing clock APIs with pm_runtime APIs.

This patch also cleans up the driver by removing the un-wanted
platform data/parameters

Signed-off-by: AnilKumar Ch <anilkumar@ti.com>
---
 drivers/net/can/d_can/d_can.c          |   23 ++++++++-
 drivers/net/can/d_can/d_can.h          |    1 +
 drivers/net/can/d_can/d_can_platform.c |   85 ++++++++++++--------------------
 include/linux/can/platform/d_can.h     |   18 ++-----
 4 files changed, 57 insertions(+), 70 deletions(-)

diff --git a/drivers/net/can/d_can/d_can.c b/drivers/net/can/d_can/d_can.c
index 7bba711..59a9cfe 100644
--- a/drivers/net/can/d_can/d_can.c
+++ b/drivers/net/can/d_can/d_can.c
@@ -37,6 +37,8 @@
 #include <linux/list.h>
 #include <linux/io.h>
 
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
 #include <linux/can.h>
 #include <linux/can/dev.h>
 #include <linux/can/error.h>
@@ -1232,11 +1234,18 @@ static int d_can_open(struct net_device *ndev)
 	int err;
 	struct d_can_priv *priv = netdev_priv(ndev);
 
+	/* If enabled, tell runtime PM not to power off */
+	if (pm_runtime_enabled(&priv->pdev->dev)) {
+		err = pm_runtime_get_sync(&priv->pdev->dev);
+		if (err < 0)
+			return err;
+	}
+
 	/* Open common can device */
 	err = open_candev(ndev);
 	if (err) {
 		netdev_err(ndev, "open_candev() failed %d\n", err);
-		return err;
+		goto exit_put_sync;
 	}
 
 	/* register interrupt handler for Message Object (MO)
@@ -1267,11 +1276,16 @@ exit_free_irq:
 	free_irq(ndev->irq, ndev);
 exit_close_candev:
 	close_candev(ndev);
+exit_put_sync:
+	if (pm_runtime_enabled(&priv->pdev->dev))
+		pm_runtime_put_sync(&priv->pdev->dev);
+
 	return err;
 }
 
 static int d_can_close(struct net_device *ndev)
 {
+	int ret;
 	struct d_can_priv *priv = netdev_priv(ndev);
 
 	netif_stop_queue(ndev);
@@ -1281,6 +1295,13 @@ static int d_can_close(struct net_device *ndev)
 	free_irq(priv->irq_obj, ndev);
 	close_candev(ndev);
 
+	/* If enabled, let runtime PM know the d_can is closed */
+	if (pm_runtime_enabled(&priv->pdev->dev)) {
+		ret = pm_runtime_put_sync(&priv->pdev->dev);
+		if (ret < 0)
+			return ret;
+	}
+
 	return 0;
 }
 
diff --git a/drivers/net/can/d_can/d_can.h b/drivers/net/can/d_can/d_can.h
index 780962e..04657bf 100644
--- a/drivers/net/can/d_can/d_can.h
+++ b/drivers/net/can/d_can/d_can.h
@@ -40,6 +40,7 @@ struct d_can_priv {
 	struct can_priv can;	/* must be the first member */
 	struct napi_struct napi;
 	struct net_device *dev;
+	struct platform_device *pdev;
 	int current_status;
 	int last_status;
 	unsigned int irqstatus;
diff --git a/drivers/net/can/d_can/d_can_platform.c b/drivers/net/can/d_can/d_can_platform.c
index 48291f7..76e127f 100644
--- a/drivers/net/can/d_can/d_can_platform.c
+++ b/drivers/net/can/d_can/d_can_platform.c
@@ -32,13 +32,8 @@
  * number to use as follows:
  *
  * static struct d_can_platform_data am33xx_evm_d_can_pdata = {
- *	.d_can_offset		= 0,
- *	.d_can_ram_offset	= 0x1000,
  *	.num_of_msg_objs	= 64,
- *	.dma_support		= true,
- *	.parity_check		= false,
- *	.fck_name		= "dcan0_fck",
- *	.ick_name		= "dcan0_ick",
+ *	.dma_support		= false,
  * };
  *
  * Please see include/linux/can/platform/d_can.h for description of
@@ -58,6 +53,7 @@
 #include <linux/platform_device.h>
 #include <linux/can/platform/d_can.h>
 #include <linux/clk.h>
+#include <linux/pm_runtime.h>
 #include <linux/slab.h>
 #include <linux/can/dev.h>
 
@@ -71,6 +67,7 @@ static int __devinit d_can_plat_probe(struct platform_device *pdev)
 	struct d_can_priv *priv;
 	struct resource *mem;
 	struct d_can_platform_data *pdata;
+	struct clk *fck;
 
 	pdata = pdev->dev.platform_data;
 	if (!pdata) {
@@ -87,36 +84,26 @@ static int __devinit d_can_plat_probe(struct platform_device *pdev)
 	}
 
 	priv = netdev_priv(ndev);
-
-	priv->fck = clk_get(&pdev->dev, pdata->fck_name);
-	if (IS_ERR(priv->fck)) {
-		dev_err(&pdev->dev, "%s is not found\n", pdata->fck_name);
+	fck = clk_get(&pdev->dev, "fck");
+	if (IS_ERR(fck)) {
+		dev_err(&pdev->dev, "fck is not found\n");
 		ret = -ENODEV;
 		goto exit_free_ndev;
 	}
-	clk_enable(priv->fck);
-
-	priv->ick = clk_get(&pdev->dev, pdata->ick_name);
-	if (IS_ERR(priv->ick)) {
-		dev_err(&pdev->dev, "%s is not found\n", pdata->ick_name);
-		ret = -ENODEV;
-		goto exit_free_fck;
-	}
-	clk_enable(priv->ick);
 
 	/* get the platform data */
 	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!mem) {
 		ret = -ENODEV;
 		dev_err(&pdev->dev, "No mem resource\n");
-		goto exit_free_clks;
+		goto exit_clk_put;
 	}
 
 	if (!request_mem_region(mem->start, resource_size(mem),
 				D_CAN_DRV_NAME)) {
 		dev_err(&pdev->dev, "resource unavailable\n");
 		ret = -EBUSY;
-		goto exit_free_clks;
+		goto exit_clk_put;
 	}
 
 	addr = ioremap(mem->start, resource_size(mem));
@@ -127,21 +114,24 @@ static int __devinit d_can_plat_probe(struct platform_device *pdev)
 	}
 
 	/* IRQ specific to Error and status & can be used for Message Object */
-	ndev->irq = platform_get_irq_byname(pdev, "int0");
+	ndev->irq = platform_get_irq_byname(pdev, "d_can_ms");
 	if (!ndev->irq) {
 		dev_err(&pdev->dev, "No irq0 resource\n");
 		goto exit_iounmap;
 	}
 
 	/* IRQ specific for Message Object */
-	priv->irq_obj = platform_get_irq_byname(pdev, "int1");
+	priv->irq_obj = platform_get_irq_byname(pdev, "d_can_mo");
 	if (!priv->irq_obj) {
 		dev_err(&pdev->dev, "No irq1 resource\n");
 		goto exit_iounmap;
 	}
 
+	pm_runtime_enable(&pdev->dev);
+	pm_runtime_get_sync(&pdev->dev);
+	priv->pdev = pdev;
 	priv->base = addr;
-	priv->can.clock.freq = clk_get_rate(priv->fck);
+	priv->can.clock.freq = clk_get_rate(fck);
 
 	platform_set_drvdata(pdev, ndev);
 	SET_NETDEV_DEV(ndev, &pdev->dev);
@@ -153,23 +143,20 @@ static int __devinit d_can_plat_probe(struct platform_device *pdev)
 		goto exit_free_device;
 	}
 
-	dev_info(&pdev->dev, "%s device registered (irq=%d, irq_obj=%d)\n",
-				D_CAN_DRV_NAME, ndev->irq, priv->irq_obj);
+	dev_info(&pdev->dev, "device registered (irq=%d, irq_obj=%d)\n",
+						ndev->irq, priv->irq_obj);
 
 	return 0;
 
 exit_free_device:
 	platform_set_drvdata(pdev, NULL);
+	pm_runtime_disable(&pdev->dev);
 exit_iounmap:
 	iounmap(addr);
 exit_release_mem:
 	release_mem_region(mem->start, resource_size(mem));
-exit_free_clks:
-	clk_disable(priv->ick);
-	clk_put(priv->ick);
-exit_free_fck:
-	clk_disable(priv->fck);
-	clk_put(priv->fck);
+exit_clk_put:
+	clk_put(fck);
 exit_free_ndev:
 	free_d_can_dev(ndev);
 exit:
@@ -193,10 +180,8 @@ static int __devexit d_can_plat_remove(struct platform_device *pdev)
 	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	release_mem_region(mem->start, resource_size(mem));
 
-	clk_disable(priv->ick);
-	clk_disable(priv->fck);
-	clk_put(priv->ick);
-	clk_put(priv->fck);
+	pm_runtime_put_sync(&pdev->dev);
+	pm_runtime_disable(&pdev->dev);
 
 	return 0;
 }
@@ -204,37 +189,29 @@ static int __devexit d_can_plat_remove(struct platform_device *pdev)
 #ifdef CONFIG_PM
 static int d_can_suspend(struct platform_device *pdev, pm_message_t state)
 {
-	struct net_device *dev = platform_get_drvdata(pdev);
-	struct d_can_priv *priv = netdev_priv(dev);
+	struct net_device *ndev = platform_get_drvdata(pdev);
+	struct d_can_priv *priv = netdev_priv(ndev);
 
-	if (netif_running(dev)) {
-		netif_stop_queue(dev);
-		netif_device_detach(dev);
+	if (netif_running(ndev)) {
+		netif_stop_queue(ndev);
+		netif_device_detach(ndev);
 	}
 
 	d_can_power_down(priv);
 	priv->can.state = CAN_STATE_SLEEPING;
-
-	clk_disable(priv->ick);
-	clk_disable(priv->fck);
-
 	return 0;
 }
 
 static int d_can_resume(struct platform_device *pdev)
 {
-	struct net_device *dev = platform_get_drvdata(pdev);
-	struct d_can_priv *priv = netdev_priv(dev);
-
-	clk_enable(priv->ick);
-	clk_enable(priv->fck);
+	struct net_device *ndev = platform_get_drvdata(pdev);
+	struct d_can_priv *priv = netdev_priv(ndev);
 
 	d_can_power_up(priv);
 	priv->can.state = CAN_STATE_ERROR_ACTIVE;
-
-	if (netif_running(dev)) {
-		netif_device_attach(dev);
-		netif_start_queue(dev);
+	if (netif_running(ndev)) {
+		netif_device_attach(ndev);
+		netif_start_queue(ndev);
 	}
 
 	return 0;
diff --git a/include/linux/can/platform/d_can.h b/include/linux/can/platform/d_can.h
index 83b02ce..dda6ea5 100644
--- a/include/linux/can/platform/d_can.h
+++ b/include/linux/can/platform/d_can.h
@@ -1,6 +1,3 @@
-#ifndef __CAN_PLATFORM_TI_D_CAN_H__
-#define __CAN_PLATFORM_TI_D_CAN_H__
-
 /*
  * D_CAN controller driver platform header
  *
@@ -21,30 +18,21 @@
  * GNU General Public License for more details.
  */
 
+#ifndef __CAN_PLATFORM_TI_D_CAN_H__
+#define __CAN_PLATFORM_TI_D_CAN_H__
+
 /**
  * struct d_can_platform_data - DCAN Platform Data
  *
- * @d_can_offset:	mostly 0 - should really never change
- * @d_can_ram_offset:	d_can RAM offset
- * @msg_obj_offset:	Mailbox RAM offset
  * @num_of_msg_objs:	Number of message objects
  * @dma_support:	DMA support is required/not
- * @parity_check:	Parity error checking is needed/not
- * @fck_name		Functional clock name
- * @ick_name		Interface clock name
  *
  * Platform data structure to get all platform specific settings.
  * this structure also accounts the fact that the IP may have different
  * RAM and mailbox offsets for different SOC's
  */
 struct d_can_platform_data {
-	u32 d_can_offset;
-	u32 d_can_ram_offset;
-	u32 msg_obj_offset;
 	u32 num_of_msg_objs;
 	bool dma_support;
-	bool parity_check;
-	char *fck_name;
-	char *ick_name;
 };
 #endif
-- 
1.7.9.5

