From 3262c40fdee25eaabcadc4abbadafdcbf2ee20e3 Mon Sep 17 00:00:00 2001
From: "Hebbar, Gururaja" <gururaja.hebbar@ti.com>
Date: Thu, 9 Feb 2012 18:25:08 +0530
Subject: [PATCH 042/182] ARM: OMAP2+: edma: move edma clock setup to edma
 driver

Let edma driver handle clock setup. Earlier this was handled during
edma device registration

Signed-off-by: Hebbar, Gururaja <gururaja.hebbar@ti.com>
---
 arch/arm/common/edma.c        |   50 +++++++++++++++++++++++++++++++++++++++++
 arch/arm/mach-omap2/devices.c |   26 ---------------------
 2 files changed, 50 insertions(+), 26 deletions(-)

diff --git a/arch/arm/common/edma.c b/arch/arm/common/edma.c
index c18c509..fa008f0 100644
--- a/arch/arm/common/edma.c
+++ b/arch/arm/common/edma.c
@@ -19,6 +19,8 @@
 #include <linux/platform_device.h>
 #include <linux/slab.h>
 #include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/err.h>
 
 #include <mach/edma.h>
 
@@ -218,6 +220,7 @@ static inline void clear_bits(int offset, int len, unsigned long *p)
 
 struct edma *edma_cc[EDMA_MAX_CC];
 static int arch_num_cc;
+static struct clk *tpcc_ick, *tptc0_ick, *tptc1_ick, *tptc2_ick;
 
 /* dummy param set used to (re)initialize parameter RAM slots */
 static const struct edmacc_param dummy_paramset = {
@@ -1343,6 +1346,24 @@ void edma_clear_event(unsigned channel)
 EXPORT_SYMBOL(edma_clear_event);
 
 /*-----------------------------------------------------------------------*/
+static int edma_clk_setup(int enb_dis)
+{
+	int ret = 0;
+
+	if (enb_dis) {
+		ret = clk_enable(tpcc_ick);
+		ret |= clk_enable(tptc0_ick);
+		ret |= clk_enable(tptc1_ick);
+		ret |= clk_enable(tptc2_ick);
+	} else {
+		clk_disable(tpcc_ick);
+		clk_disable(tptc0_ick);
+		clk_disable(tptc1_ick);
+		clk_disable(tptc2_ick);
+	}
+
+	return ret;
+}
 
 static int __init edma_probe(struct platform_device *pdev)
 {
@@ -1363,6 +1384,34 @@ static int __init edma_probe(struct platform_device *pdev)
 	if (!info)
 		return -ENODEV;
 
+	tpcc_ick = clk_get(NULL, "tpcc_ick");
+	if (IS_ERR(tpcc_ick)) {
+		printk(KERN_ERR "EDMA: Failed to get tpcc_ick\n");
+		return -EBUSY;
+	}
+
+	tptc0_ick = clk_get(NULL, "tptc0_ick");
+	if (IS_ERR(tptc0_ick)) {
+		printk(KERN_ERR "EDMA: Failed to get tptc0_ick\n");
+		return -EBUSY;
+	}
+
+	tptc1_ick = clk_get(NULL, "tptc1_ick");
+	if (IS_ERR(tptc1_ick)) {
+		printk(KERN_ERR "EDMA: Failed to get tptc1_ick\n");
+		return -EBUSY;
+	}
+
+	tptc2_ick = clk_get(NULL, "tptc2_ick");
+	if (IS_ERR(tptc2_ick)) {
+		printk(KERN_ERR "EDMA: Failed to get tptc2_ick\n");
+		return -EBUSY;
+	}
+
+	status = edma_clk_setup(1);
+	if (status)
+		return status;
+
 	for (j = 0; j < EDMA_MAX_CC; j++) {
 		sprintf(res_name, "edma_cc%d", j);
 		r[j] = platform_get_resource_byname(pdev, IORESOURCE_MEM,
@@ -1525,6 +1574,7 @@ fail1:
 			iounmap(edmacc_regs_base[i]);
 		kfree(edma_cc[i]);
 	}
+	edma_clk_setup(0);
 	return status;
 }
 
diff --git a/arch/arm/mach-omap2/devices.c b/arch/arm/mach-omap2/devices.c
index 9b5c059..137962e 100644
--- a/arch/arm/mach-omap2/devices.c
+++ b/arch/arm/mach-omap2/devices.c
@@ -1044,7 +1044,6 @@ static struct platform_device am33xx_edma_device = {
 int __init am33xx_register_edma(void)
 {
 	struct platform_device *pdev;
-	static struct clk *edma_clk;
 
 	if (cpu_is_am33xx())
 		pdev = &am33xx_edma_device;
@@ -1053,31 +1052,6 @@ int __init am33xx_register_edma(void)
 		return -ENODEV;
 	}
 
-	edma_clk = clk_get(NULL, "tpcc_ick");
-	if (IS_ERR(edma_clk)) {
-		printk(KERN_ERR "EDMA: Failed to get clock\n");
-		return -EBUSY;
-	}
-	clk_enable(edma_clk);
-	edma_clk = clk_get(NULL, "tptc0_ick");
-	if (IS_ERR(edma_clk)) {
-		printk(KERN_ERR "EDMA: Failed to get clock\n");
-		return -EBUSY;
-	}
-	clk_enable(edma_clk);
-	edma_clk = clk_get(NULL, "tptc1_ick");
-	if (IS_ERR(edma_clk)) {
-		printk(KERN_ERR "EDMA: Failed to get clock\n");
-		return -EBUSY;
-	}
-	clk_enable(edma_clk);
-	edma_clk = clk_get(NULL, "tptc2_ick");
-	if (IS_ERR(edma_clk)) {
-		printk(KERN_ERR "EDMA: Failed to get clock\n");
-		return -EBUSY;
-	}
-	clk_enable(edma_clk);
-
 	return platform_device_register(pdev);
 }
 
-- 
1.7.9.1

