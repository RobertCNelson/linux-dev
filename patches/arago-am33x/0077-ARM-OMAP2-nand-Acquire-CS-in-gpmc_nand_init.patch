From 44b0b076aaf275482a6ad1a53c5ad3cf18739c23 Mon Sep 17 00:00:00 2001
From: Afzal Mohammed <afzal@ti.com>
Date: Wed, 29 Feb 2012 18:11:56 +0530
Subject: [PATCH 077/175] ARM: OMAP2+: nand: Acquire CS in gpmc_nand_init

Prerequisite to merging different board nand functions to one

Signed-off-by: Afzal Mohammed <afzal@ti.com>
---
 arch/arm/mach-omap2/common-board-devices.c |   37 ++++-----------------------
 arch/arm/mach-omap2/gpmc-nand.c            |   23 +++++++++++++++++
 2 files changed, 29 insertions(+), 31 deletions(-)

diff --git a/arch/arm/mach-omap2/common-board-devices.c b/arch/arm/mach-omap2/common-board-devices.c
index 2d1d775..f23a601 100644
--- a/arch/arm/mach-omap2/common-board-devices.c
+++ b/arch/arm/mach-omap2/common-board-devices.c
@@ -98,38 +98,13 @@ static struct omap_nand_platform_data nand_data;
 void __init omap_nand_flash_init(int options, struct mtd_partition *parts,
 				 int nr_parts)
 {
-	u8 cs = 0;
-	u8 nandcs = GPMC_CS_NUM + 1;
-
-	/* find out the chip-select on which NAND exists */
-	while (cs < GPMC_CS_NUM) {
-		u32 ret = 0;
-		ret = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG1);
-
-		if ((ret & 0xC00) == 0x800) {
-			printk(KERN_INFO "Found NAND on CS%d\n", cs);
-			if (nandcs > GPMC_CS_NUM)
-				nandcs = cs;
-		}
-		cs++;
-	}
-
-	if (nandcs > GPMC_CS_NUM) {
-		printk(KERN_INFO "NAND: Unable to find configuration "
-				 "in GPMC\n ");
-		return;
-	}
-
-	if (nandcs < GPMC_CS_NUM) {
-		nand_data.cs = nandcs;
-		nand_data.parts = parts;
-		nand_data.nr_parts = nr_parts;
-		nand_data.devsize = options;
+	nand_data.cs = GPMC_CS_NUM + 1;
+	nand_data.parts = parts;
+	nand_data.nr_parts = nr_parts;
+	nand_data.devsize = options;
 
-		printk(KERN_INFO "Registering NAND on CS%d\n", nandcs);
-		if (gpmc_nand_init(&nand_data) < 0)
-			printk(KERN_ERR "Unable to register NAND device\n");
-	}
+	if (gpmc_nand_init(&nand_data) < 0)
+		printk(KERN_ERR "Unable to register NAND device\n");
 }
 #else
 void __init omap_nand_flash_init(int options, struct mtd_partition *parts,
diff --git a/arch/arm/mach-omap2/gpmc-nand.c b/arch/arm/mach-omap2/gpmc-nand.c
index 8ad210b..2de65d1 100644
--- a/arch/arm/mach-omap2/gpmc-nand.c
+++ b/arch/arm/mach-omap2/gpmc-nand.c
@@ -84,10 +84,33 @@ static int omap2_nand_gpmc_retime(struct omap_nand_platform_data *gpmc_nand_data
 int __init gpmc_nand_init(struct omap_nand_platform_data *gpmc_nand_data)
 {
 	int err	= 0;
+	u8 cs = 0;
 	struct device *dev = &gpmc_nand_device.dev;
 
+	/* if cs not provided, find out the chip-select on which NAND exist */
+	if (gpmc_nand_data->cs > GPMC_CS_NUM)
+		while (cs < GPMC_CS_NUM) {
+			u32 ret = 0;
+			ret = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG1);
+
+			if ((ret & 0xC00) == 0x800) {
+				printk(KERN_INFO "Found NAND on CS%d\n", cs);
+				gpmc_nand_data->cs = cs;
+				break;
+			}
+			cs++;
+		}
+
+	if (gpmc_nand_data->cs > GPMC_CS_NUM) {
+		printk(KERN_INFO "NAND: Unable to find configuration "
+				 "in GPMC\n ");
+		return -ENODEV;
+	}
+
 	gpmc_nand_device.dev.platform_data = gpmc_nand_data;
 
+	printk(KERN_INFO "Registering NAND on CS%d\n", gpmc_nand_data->cs);
+
 	err = gpmc_cs_request(gpmc_nand_data->cs, NAND_IO_SIZE,
 				&gpmc_nand_data->phys_base);
 	if (err < 0) {
-- 
1.7.9.1

