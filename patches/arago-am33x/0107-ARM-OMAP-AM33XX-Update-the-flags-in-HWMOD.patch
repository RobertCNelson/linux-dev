From 453879c97d4e56a33d8e8f87b0dbc979c45b7c5f Mon Sep 17 00:00:00 2001
From: Vaibhav Bedia <vaibhav.bedia@ti.com>
Date: Thu, 9 Feb 2012 23:04:02 +0530
Subject: [PATCH 107/175] ARM: OMAP: AM33XX: Update the flags in HWMOD

For the modules which require special handling, update
the flags in the hwmod data. WIth this done, the PM
framework takes care of the special handling for the
modules.

Note: With HWMOD_SWSUP_MSTANDBY set, the module goes
to standby during boot. Unless the driver makes use
of runtime PM APIs the module will stay in standby
which is not desired. For now we disable idling
this modules during the boot. When the drivers start
making use of runtime PM this workaround must be
removed.

All this should eventually make its way into the
appropriate drivers.

Signed-off-by: Vaibhav Bedia <vaibhav.bedia@ti.com>
---
 arch/arm/mach-omap2/omap_hwmod_33xx_data.c |   11 +++++++++++
 1 files changed, 11 insertions(+), 0 deletions(-)

diff --git a/arch/arm/mach-omap2/omap_hwmod_33xx_data.c b/arch/arm/mach-omap2/omap_hwmod_33xx_data.c
index b13c1ae8..037d2d3 100644
--- a/arch/arm/mach-omap2/omap_hwmod_33xx_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_33xx_data.c
@@ -500,6 +500,8 @@ static struct omap_hwmod am33xx_cpgmac0_hwmod = {
 	},
 	.slaves		= am33xx_cpgmac0_slaves,
 	.slaves_cnt	= ARRAY_SIZE(am33xx_cpgmac0_slaves),
+	.flags		= (HWMOD_SWSUP_SIDLE | HWMOD_SWSUP_MSTANDBY |
+				HWMOD_INIT_NO_IDLE | HWMOD_INIT_NO_RESET),
 };
 
 /* 'dcan' class */
@@ -1022,6 +1024,8 @@ static struct omap_hwmod am33xx_gpmc_hwmod = {
 	},
 	.slaves		= am33xx_gpmc_slaves,
 	.slaves_cnt	= ARRAY_SIZE(am33xx_gpmc_slaves),
+	.flags		= (HWMOD_SWSUP_SIDLE | HWMOD_SWSUP_MSTANDBY |
+				HWMOD_INIT_NO_IDLE | HWMOD_INIT_NO_RESET),
 };
 
 /* 'i2c' class */
@@ -1344,6 +1348,7 @@ static struct omap_hwmod am33xx_lcdc_hwmod = {
 	},
 	.slaves		= am33xx_lcdc_slaves,
 	.slaves_cnt	= ARRAY_SIZE(am33xx_lcdc_slaves),
+	.flags		= (HWMOD_SWSUP_SIDLE | HWMOD_SWSUP_MSTANDBY),
 };
 
 /*
@@ -2037,6 +2042,7 @@ static struct omap_hwmod am33xx_timer0_hwmod = {
 	},
 	.slaves		= am33xx_timer0_slaves,
 	.slaves_cnt	= ARRAY_SIZE(am33xx_timer0_slaves),
+	.flags		= (HWMOD_INIT_NO_IDLE | HWMOD_INIT_NO_RESET),
 };
 
 /* timer1 1ms */
@@ -2474,6 +2480,7 @@ static struct omap_hwmod am33xx_tptc0_hwmod = {
 	},
 	.slaves		= am33xx_tptc0_slaves,
 	.slaves_cnt	= ARRAY_SIZE(am33xx_tptc0_slaves),
+	.flags		= (HWMOD_SWSUP_SIDLE | HWMOD_SWSUP_MSTANDBY),
 };
 
 /* tptc1 */
@@ -2517,6 +2524,7 @@ static struct omap_hwmod am33xx_tptc1_hwmod = {
 	},
 	.slaves		= am33xx_tptc1_slaves,
 	.slaves_cnt	= ARRAY_SIZE(am33xx_tptc1_slaves),
+	.flags		= (HWMOD_SWSUP_SIDLE | HWMOD_SWSUP_MSTANDBY),
 };
 
 /* tptc2 */
@@ -2560,6 +2568,7 @@ static struct omap_hwmod am33xx_tptc2_hwmod = {
 	},
 	.slaves		= am33xx_tptc2_slaves,
 	.slaves_cnt	= ARRAY_SIZE(am33xx_tptc2_slaves),
+	.flags		= (HWMOD_SWSUP_SIDLE | HWMOD_SWSUP_MSTANDBY),
 };
 
 /* 'uart' class */
@@ -2994,6 +3003,8 @@ static struct omap_hwmod am33xx_usbss_hwmod = {
 	},
 	.slaves		= am33xx_usbss_slaves,
 	.slaves_cnt	= ARRAY_SIZE(am33xx_usbss_slaves),
+	.class		= &am33xx_usbotg_class,
+	.flags		= (HWMOD_SWSUP_SIDLE | HWMOD_SWSUP_MSTANDBY),
 };
 
 /* gfx */
-- 
1.7.9.1

