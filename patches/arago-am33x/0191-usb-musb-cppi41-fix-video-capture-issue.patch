From c31e70e7a38d57a710d15562ed3fe517df2cef01 Mon Sep 17 00:00:00 2001
From: Ajay Kumar Gupta <ajay.gupta@ti.com>
Date: Wed, 21 Mar 2012 13:40:25 +0530
Subject: [PATCH 191/193] usb: musb: cppi41: fix video capture issue

Fixes video capture issue with Logitech-prp9000 for 640X460 resolution.
The issues was with cppi41 dma programming for transparent mode with
high bandwidth endpoints where it was not taking care of multiple
maxpacket size data within one micro frame.

Added hb_mult to cppi41_channel structure to take care of such scenarios.
---
 drivers/usb/musb/cppi41_dma.c |    6 ++++--
 drivers/usb/musb/musb_host.c  |   16 +++++++++-------
 2 files changed, 13 insertions(+), 9 deletions(-)

diff --git a/drivers/usb/musb/cppi41_dma.c b/drivers/usb/musb/cppi41_dma.c
index b90a1ff..69a952d 100644
--- a/drivers/usb/musb/cppi41_dma.c
+++ b/drivers/usb/musb/cppi41_dma.c
@@ -100,6 +100,7 @@ struct cppi41_channel {
 	u8  zlp_queued;
 	u8  inf_mode;
 	u8  tx_complete;
+	u8  hb_mult;
 };
 
 /**
@@ -798,7 +799,7 @@ static unsigned cppi41_next_rx_segment(struct cppi41_channel *rx_ch)
 		} else {
 			cppi41_mode_update(rx_ch, USB_TRANSPARENT_MODE);
 			cppi41_autoreq_update(rx_ch, USB_NO_AUTOREQ);
-			max_rx_transfer_size = rx_ch->pkt_size;
+			max_rx_transfer_size = rx_ch->hb_mult * rx_ch->pkt_size;
 		}
 	}
 
@@ -913,7 +914,8 @@ static int cppi41_channel_program(struct dma_channel *channel,	u16 maxpacket,
 	/* Set the transfer parameters, then queue up the first segment */
 	cppi_ch->start_addr = dma_addr;
 	cppi_ch->curr_offset = 0;
-	cppi_ch->pkt_size = maxpacket;
+	cppi_ch->hb_mult = (maxpacket >> 11) & 0x03;
+	cppi_ch->pkt_size = maxpacket & 0x7ff;
 	cppi_ch->length = length;
 	cppi_ch->transfer_mode = mode;
 	cppi_ch->zlp_queued = 0;
diff --git a/drivers/usb/musb/musb_host.c b/drivers/usb/musb/musb_host.c
index bea4b34..c4d44fa 100644
--- a/drivers/usb/musb/musb_host.c
+++ b/drivers/usb/musb/musb_host.c
@@ -710,7 +710,8 @@ static bool musb_tx_dma_program(struct dma_controller *dma,
 	 */
 	wmb();
 
-	if (!dma->channel_program(channel, pkt_size, mode,
+	if (!dma->channel_program(channel, pkt_size |
+			(qh->hb_mult << 11), mode,
 			urb->transfer_dma + offset, length)) {
 		dma->channel_release(channel);
 		hw_ep->tx_channel = NULL;
@@ -835,9 +836,8 @@ static void musb_ep_program(struct musb *musb, u8 epnum,
 					| ((hw_ep->max_packet_sz_tx /
 						packet_sz) - 1) << 11);
 			else
-				musb_writew(epio, MUSB_TXMAXP,
-						qh->maxpacket |
-						((qh->hb_mult - 1) << 11));
+				musb_writew(epio, MUSB_TXMAXP, qh->maxpacket |
+						(qh->hb_mult << 11));
 			musb_writeb(epio, MUSB_TXINTERVAL, qh->intv_reg);
 		} else {
 			musb_writeb(epio, MUSB_NAKLIMIT0, qh->intv_reg);
@@ -911,7 +911,8 @@ static void musb_ep_program(struct musb *musb, u8 epnum,
 			 * errors, we dare not queue multiple transfers.
 			 */
 			dma_ok = dma_controller->channel_program(dma_channel,
-					packet_sz, !(urb->transfer_flags &
+					packet_sz | (qh->hb_mult << 11),
+					 !(urb->transfer_flags &
 						     URB_SHORT_NOT_OK),
 					urb->transfer_dma + offset,
 					qh->segsize);
@@ -1681,7 +1682,8 @@ void musb_host_rx(struct musb *musb, u8 epnum)
 				length =
 					urb->iso_frame_desc[qh->iso_idx].length;
 
-				ret = c->channel_program(dma, qh->maxpacket,
+				ret = c->channel_program(dma, qh->maxpacket |
+						(qh->hb_mult << 11),
 						0, (u32) buf, length);
 				done = false;
 			} else {
@@ -1827,7 +1829,7 @@ void musb_host_rx(struct musb *musb, u8 epnum)
 			 * adjusted first...
 			 */
 			ret = c->channel_program(
-				dma, qh->maxpacket,
+				dma, qh->maxpacket | ((qh->hb_mult - 1) << 11),
 				dma->desired_mode, buf, length);
 
 			if (!ret) {
-- 
1.7.9.5

