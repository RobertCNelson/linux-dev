From 424ba9bbb8e693b380a63f9f6408c4df9e79b425 Mon Sep 17 00:00:00 2001
From: AnilKumar Ch <anilkumar@ti.com>
Date: Tue, 6 Mar 2012 19:24:35 +0530
Subject: [PATCH 062/172] ARM: OMAP: AM33XX: CAN: d_can: fix DCAN raminit
 issue

This patch fixes the DCAN raminit problem

Details:
DCAN RAM initialization is not complete and clock disable
is not working as expected after doing the d_can_open().

Before this patch, implementation is like doing DCAN RAM init
first and then enabling the clocks. This was done this way
because RAM init bits are from the control module register.

Workaround:
DCAN clocks should be enable first and then DCAN ram
initialization

Signed-off-by: AnilKumar Ch <anilkumar@ti.com>
---
 drivers/net/can/d_can/d_can.c          |   11 +++++++++++
 drivers/net/can/d_can/d_can.h          |    3 +++
 drivers/net/can/d_can/d_can_platform.c |   15 +++++++++++++++
 include/linux/can/platform/d_can.h     |    2 ++
 4 files changed, 31 insertions(+), 0 deletions(-)

diff --git a/drivers/net/can/d_can/d_can.c b/drivers/net/can/d_can/d_can.c
index 59a9cfe..f1bf3a8 100644
--- a/drivers/net/can/d_can/d_can.c
+++ b/drivers/net/can/d_can/d_can.c
@@ -1305,6 +1305,17 @@ static int d_can_close(struct net_device *ndev)
 	return 0;
 }
 
+void d_can_reset_ram(struct d_can_priv *d_can, unsigned int instance,
+					unsigned int enable)
+{
+	if (d_can->ram_init)
+		d_can->ram_init(instance, enable);
+
+	/* Give some time delay for DCAN RAM initialization */
+	udelay(1);
+}
+EXPORT_SYMBOL_GPL(d_can_reset_ram);
+
 struct net_device *alloc_d_can_dev(int num_objs)
 {
 	struct net_device *dev;
diff --git a/drivers/net/can/d_can/d_can.h b/drivers/net/can/d_can/d_can.h
index 04657bf..a2cd472 100644
--- a/drivers/net/can/d_can/d_can.h
+++ b/drivers/net/can/d_can/d_can.h
@@ -56,6 +56,7 @@ struct d_can_priv {
 	unsigned int tx_echo;
 	unsigned int rx_next;
 	void *priv;		/* for board-specific data */
+	void (*ram_init) (unsigned int, unsigned int);
 };
 
 struct net_device *alloc_d_can_dev(int);
@@ -64,5 +65,7 @@ void d_can_power_up(struct d_can_priv *d_can);
 void d_can_power_down(struct d_can_priv *d_can);
 int register_d_can_dev(struct net_device *dev);
 void unregister_d_can_dev(struct net_device *dev);
+void d_can_reset_ram(struct d_can_priv *d_can, unsigned int instance,
+					unsigned int enable);
 
 #endif /* D_CAN_H */
diff --git a/drivers/net/can/d_can/d_can_platform.c b/drivers/net/can/d_can/d_can_platform.c
index 76e127f..b114e45 100644
--- a/drivers/net/can/d_can/d_can_platform.c
+++ b/drivers/net/can/d_can/d_can_platform.c
@@ -34,6 +34,7 @@
  * static struct d_can_platform_data am33xx_evm_d_can_pdata = {
  *	.num_of_msg_objs	= 64,
  *	.dma_support		= false,
+ *	.ram_init		= d_can_hw_raminit,
  * };
  *
  * Please see include/linux/can/platform/d_can.h for description of
@@ -132,6 +133,7 @@ static int __devinit d_can_plat_probe(struct platform_device *pdev)
 	priv->pdev = pdev;
 	priv->base = addr;
 	priv->can.clock.freq = clk_get_rate(fck);
+	priv->ram_init = pdata->ram_init;
 
 	platform_set_drvdata(pdev, ndev);
 	SET_NETDEV_DEV(ndev, &pdev->dev);
@@ -143,6 +145,9 @@ static int __devinit d_can_plat_probe(struct platform_device *pdev)
 		goto exit_free_device;
 	}
 
+	/* Initialize DCAN RAM */
+	d_can_reset_ram(priv, pdev->id, 1);
+
 	dev_info(&pdev->dev, "device registered (irq=%d, irq_obj=%d)\n",
 						ndev->irq, priv->irq_obj);
 
@@ -171,6 +176,9 @@ static int __devexit d_can_plat_remove(struct platform_device *pdev)
 	struct d_can_priv *priv = netdev_priv(ndev);
 	struct resource *mem;
 
+	/* De-initialize DCAN RAM */
+	d_can_reset_ram(priv, pdev->id, 0);
+
 	unregister_d_can_dev(ndev);
 	platform_set_drvdata(pdev, NULL);
 
@@ -192,6 +200,9 @@ static int d_can_suspend(struct platform_device *pdev, pm_message_t state)
 	struct net_device *ndev = platform_get_drvdata(pdev);
 	struct d_can_priv *priv = netdev_priv(ndev);
 
+	/* De-initialize DCAN RAM */
+	d_can_reset_ram(priv, pdev->id, 0);
+
 	if (netif_running(ndev)) {
 		netif_stop_queue(ndev);
 		netif_device_detach(ndev);
@@ -208,6 +219,10 @@ static int d_can_resume(struct platform_device *pdev)
 	struct d_can_priv *priv = netdev_priv(ndev);
 
 	d_can_power_up(priv);
+
+	/* Initialize DCAN RAM */
+	d_can_reset_ram(priv, pdev->id, 1);
+
 	priv->can.state = CAN_STATE_ERROR_ACTIVE;
 	if (netif_running(ndev)) {
 		netif_device_attach(ndev);
diff --git a/include/linux/can/platform/d_can.h b/include/linux/can/platform/d_can.h
index dda6ea5..fe9df47 100644
--- a/include/linux/can/platform/d_can.h
+++ b/include/linux/can/platform/d_can.h
@@ -26,6 +26,7 @@
  *
  * @num_of_msg_objs:	Number of message objects
  * @dma_support:	DMA support is required/not
+ * @ram_init:		DCAN RAM initialization
  *
  * Platform data structure to get all platform specific settings.
  * this structure also accounts the fact that the IP may have different
@@ -34,5 +35,6 @@
 struct d_can_platform_data {
 	u32 num_of_msg_objs;
 	bool dma_support;
+	void (*ram_init) (unsigned int, unsigned int);
 };
 #endif
-- 
1.7.9.1

